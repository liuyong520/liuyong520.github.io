<!-- build time:Sun Jun 02 2019 15:29:17 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Docker 容器技术 | 跛足的登山者</title><meta name="description" content="一、Docker 简介Docker是一个新的容器化的技术，它轻巧，且易移植。Docker 组件与元素Docker有三个组件和三个基本元素。三个组件分别是：Docker Client 是用户界面，它支持用户与Docker Daemon之间通信。Docker Daemon运行于主机上，处理服务请求。Docker Index是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。"><meta name="keywords" content="docker"><meta property="og:type" content="article"><meta property="og:title" content="Docker 容器技术"><meta property="og:url" content="http://www.liuyong520.cn/2018/02/12/docker/index.html"><meta property="og:site_name" content="跛足的登山者"><meta property="og:description" content="一、Docker 简介Docker是一个新的容器化的技术，它轻巧，且易移植。Docker 组件与元素Docker有三个组件和三个基本元素。三个组件分别是：Docker Client 是用户界面，它支持用户与Docker Daemon之间通信。Docker Daemon运行于主机上，处理服务请求。Docker Index是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://topweshare.qiniudn.com/1522984222.png?imageMogr2/thumbnail/!70p"><meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20150212/20150212091034_634.png"><meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_252.png"><meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_900.png"><meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_912.png"><meta property="og:updated_time" content="2019-05-14T08:23:56.492Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Docker 容器技术"><meta name="twitter:description" content="一、Docker 简介Docker是一个新的容器化的技术，它轻巧，且易移植。Docker 组件与元素Docker有三个组件和三个基本元素。三个组件分别是：Docker Client 是用户界面，它支持用户与Docker Daemon之间通信。Docker Daemon运行于主机上，处理服务请求。Docker Index是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。"><meta name="twitter:image" content="http://topweshare.qiniudn.com/1522984222.png?imageMogr2/thumbnail/!70p"><link rel="canonical" href="http://www.liuyong520.cn/2018/02/12/docker/index.html"><link rel="alternate" href="/atom.xml" title="跛足的登山者" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/liuyong520" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">跛足的登山者</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">非著名java程序员</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">书单</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/liuyong520" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/1886570943" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar sidebar-toc" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Docker-简介"><span class="toc-number">1.</span> <span class="toc-text">一、Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-组件与元素"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 组件与元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Docker-守护进程"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 Docker 守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Docker-客户端"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 Docker 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Docker-内部"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 Docker 内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-镜像"><span class="toc-number">1.4.1.</span> <span class="toc-text">Docker 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-仓库"><span class="toc-number">1.4.2.</span> <span class="toc-text">Docker 仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-容器"><span class="toc-number">1.4.3.</span> <span class="toc-text">Docker 容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Docker-安装"><span class="toc-number">2.</span> <span class="toc-text">二、Docker 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Docker-基础用法"><span class="toc-number">3.</span> <span class="toc-text">三、Docker 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Search-images"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Search images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Pull-images"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Pull images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Running-an-interactive-shell"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Running an interactive shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Docker-命令帮助"><span class="toc-number">4.</span> <span class="toc-text">四、Docker 命令帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-docker-help"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 docker help</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-command"><span class="toc-number">4.1.1.</span> <span class="toc-text">docker command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-option"><span class="toc-number">4.1.2.</span> <span class="toc-text">docker option</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-docker-search"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 docker search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-docker-info"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 docker info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-docker-pull-amp-amp-docker-push"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 docker pull &amp;&amp; docker push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-docker-images"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 docker images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-docker-rmi"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 docker rmi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-docker-run"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 docker run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-docker-start-stop-kill…-…"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 docker start|stop|kill… …</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Docker-端口映射"><span class="toc-number">5.</span> <span class="toc-text">五、Docker 端口映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-自动映射端口"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 自动映射端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-绑定端口到指定接口"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 绑定端口到指定接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-TCP-端口"><span class="toc-number">5.2.1.</span> <span class="toc-text">绑定 TCP 端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-UDP-端口"><span class="toc-number">5.2.2.</span> <span class="toc-text">绑定 UDP 端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Docker-网络配置"><span class="toc-number">6.</span> <span class="toc-text">六、Docker 网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Docker-四种网络模式"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Docker 四种网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#host-模式"><span class="toc-number">6.1.1.</span> <span class="toc-text">host 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#container-模式"><span class="toc-number">6.1.2.</span> <span class="toc-text">container 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#none模式"><span class="toc-number">6.1.3.</span> <span class="toc-text">none模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bridge模式"><span class="toc-number">6.1.4.</span> <span class="toc-text">bridge模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-列出当前主机网桥"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 列出当前主机网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-查看当前-docker0-ip"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 查看当前 docker0 ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-运行一个容器"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 运行一个容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用特定范围的-IP"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用特定范围的 IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-不同主机间容器通信"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 不同主机间容器通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装相应依赖软件"><span class="toc-number">6.5.1.</span> <span class="toc-text">安装相应依赖软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桥接网络"><span class="toc-number">6.5.2.</span> <span class="toc-text">桥接网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipework"><span class="toc-number">6.5.3.</span> <span class="toc-text">pipework</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Dockerfile"><span class="toc-number">7.</span> <span class="toc-text">七、Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-FROM"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-MAINTAINER"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 MAINTAINER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-CMD"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-EXPOSE"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-ENV"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-ADD"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-COPY"><span class="toc-number">7.7.</span> <span class="toc-text">7.7 COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-ENTRYPOINT"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exec-form-ENTRYPOINT-例子"><span class="toc-number">7.8.1.</span> <span class="toc-text">Exec form ENTRYPOINT 例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell-form-ENTRYPOINT-例子"><span class="toc-number">7.8.2.</span> <span class="toc-text">Shell form ENTRYPOINT 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-VOLUME"><span class="toc-number">7.9.</span> <span class="toc-text">7.9 VOLUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-USER"><span class="toc-number">7.10.</span> <span class="toc-text">7.10 USER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-WORKDIR"><span class="toc-number">7.11.</span> <span class="toc-text">7.11 WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-ONBUILD"><span class="toc-number">7.12.</span> <span class="toc-text">7.12 ONBUILD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-Dockerfile-Examples"><span class="toc-number">7.13.</span> <span class="toc-text">7.13 Dockerfile Examples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-14-docker-build"><span class="toc-number">7.14.</span> <span class="toc-text">7.14 docker build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15-dockerfile-最佳实践"><span class="toc-number">7.15.</span> <span class="toc-text">7.15 dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-指令"><span class="toc-number">7.15.1.</span> <span class="toc-text">Dockerfile 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、容器数据管理"><span class="toc-number">8.</span> <span class="toc-text">八、容器数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-数据卷"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加一个数据卷"><span class="toc-number">8.1.1.</span> <span class="toc-text">添加一个数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂载宿主机目录为一个数据卷"><span class="toc-number">8.1.2.</span> <span class="toc-text">挂载宿主机目录为一个数据卷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-创建和挂载一个数据卷容器"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 创建和挂载一个数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-备份、恢复或迁移数据卷"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 备份、恢复或迁移数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备份"><span class="toc-number">8.3.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复"><span class="toc-number">8.3.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-删除-Volumes"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 删除 Volumes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、链接容器"><span class="toc-number">9.</span> <span class="toc-text">九、链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-容器命名"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 容器命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-链接容器"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量"><span class="toc-number">9.2.1.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新-etc-hosts文件"><span class="toc-number">9.2.2.</span> <span class="toc-text">更新/etc/hosts文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、构建私有库"><span class="toc-number">10.</span> <span class="toc-text">十、构建私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-快速构建"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 快速构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-不使用容器构建-registry"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 不使用容器构建 registry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装必要的软件"><span class="toc-number">10.2.1.</span> <span class="toc-text">安装必要的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-docker-registry"><span class="toc-number">10.2.2.</span> <span class="toc-text">配置 docker-registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行"><span class="toc-number">10.2.3.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级启动方式-不推荐"><span class="toc-number">10.2.4.</span> <span class="toc-text">高级启动方式 [不推荐]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-提交指定容器到私有库"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 提交指定容器到私有库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、docker-启动redis"><span class="toc-number">11.</span> <span class="toc-text">十一、docker 启动redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、docker-部署zookeeper"><span class="toc-number">12.</span> <span class="toc-text">十二、docker 部署zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZK-集群的搭建"><span class="toc-number">13.</span> <span class="toc-text">ZK 集群的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Docker-命令行客户端连接-ZK-集群"><span class="toc-number">13.1.</span> <span class="toc-text">使用 Docker 命令行客户端连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过本地主机连接-ZK-集群"><span class="toc-number">13.2.</span> <span class="toc-text">通过本地主机连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看集群"><span class="toc-number">13.3.</span> <span class="toc-text">查看集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、docker-部署-rabbitmq"><span class="toc-number">14.</span> <span class="toc-text">十三、docker 部署 rabbitmq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-、启动Eureka"><span class="toc-number">15.</span> <span class="toc-text">十四 、启动Eureka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五-、启动Config-Server"><span class="toc-number">16.</span> <span class="toc-text">十五 、启动Config Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六-、启动-mysql"><span class="toc-number">17.</span> <span class="toc-text">十六 、启动 mysql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七、启动nginx"><span class="toc-number">18.</span> <span class="toc-text">十七、启动nginx</span></a></li></ol></nav></div></aside><aside class="sidebar sidebar-toc" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Docker-简介"><span class="toc-number">1.</span> <span class="toc-text">一、Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-组件与元素"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 组件与元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Docker-守护进程"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 Docker 守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Docker-客户端"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 Docker 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Docker-内部"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 Docker 内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-镜像"><span class="toc-number">1.4.1.</span> <span class="toc-text">Docker 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-仓库"><span class="toc-number">1.4.2.</span> <span class="toc-text">Docker 仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-容器"><span class="toc-number">1.4.3.</span> <span class="toc-text">Docker 容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Docker-安装"><span class="toc-number">2.</span> <span class="toc-text">二、Docker 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Docker-基础用法"><span class="toc-number">3.</span> <span class="toc-text">三、Docker 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Search-images"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Search images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Pull-images"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Pull images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Running-an-interactive-shell"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Running an interactive shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Docker-命令帮助"><span class="toc-number">4.</span> <span class="toc-text">四、Docker 命令帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-docker-help"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 docker help</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-command"><span class="toc-number">4.1.1.</span> <span class="toc-text">docker command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-option"><span class="toc-number">4.1.2.</span> <span class="toc-text">docker option</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-docker-search"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 docker search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-docker-info"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 docker info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-docker-pull-amp-amp-docker-push"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 docker pull &amp;&amp; docker push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-docker-images"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 docker images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-docker-rmi"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 docker rmi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-docker-run"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 docker run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-docker-start-stop-kill…-…"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 docker start|stop|kill… …</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Docker-端口映射"><span class="toc-number">5.</span> <span class="toc-text">五、Docker 端口映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-自动映射端口"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 自动映射端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-绑定端口到指定接口"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 绑定端口到指定接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-TCP-端口"><span class="toc-number">5.2.1.</span> <span class="toc-text">绑定 TCP 端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-UDP-端口"><span class="toc-number">5.2.2.</span> <span class="toc-text">绑定 UDP 端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Docker-网络配置"><span class="toc-number">6.</span> <span class="toc-text">六、Docker 网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Docker-四种网络模式"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Docker 四种网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#host-模式"><span class="toc-number">6.1.1.</span> <span class="toc-text">host 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#container-模式"><span class="toc-number">6.1.2.</span> <span class="toc-text">container 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#none模式"><span class="toc-number">6.1.3.</span> <span class="toc-text">none模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bridge模式"><span class="toc-number">6.1.4.</span> <span class="toc-text">bridge模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-列出当前主机网桥"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 列出当前主机网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-查看当前-docker0-ip"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 查看当前 docker0 ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-运行一个容器"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 运行一个容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用特定范围的-IP"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用特定范围的 IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-不同主机间容器通信"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 不同主机间容器通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装相应依赖软件"><span class="toc-number">6.5.1.</span> <span class="toc-text">安装相应依赖软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桥接网络"><span class="toc-number">6.5.2.</span> <span class="toc-text">桥接网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipework"><span class="toc-number">6.5.3.</span> <span class="toc-text">pipework</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Dockerfile"><span class="toc-number">7.</span> <span class="toc-text">七、Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-FROM"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-MAINTAINER"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 MAINTAINER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-CMD"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-EXPOSE"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-ENV"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-ADD"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-COPY"><span class="toc-number">7.7.</span> <span class="toc-text">7.7 COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-ENTRYPOINT"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exec-form-ENTRYPOINT-例子"><span class="toc-number">7.8.1.</span> <span class="toc-text">Exec form ENTRYPOINT 例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell-form-ENTRYPOINT-例子"><span class="toc-number">7.8.2.</span> <span class="toc-text">Shell form ENTRYPOINT 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-VOLUME"><span class="toc-number">7.9.</span> <span class="toc-text">7.9 VOLUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-USER"><span class="toc-number">7.10.</span> <span class="toc-text">7.10 USER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-WORKDIR"><span class="toc-number">7.11.</span> <span class="toc-text">7.11 WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-ONBUILD"><span class="toc-number">7.12.</span> <span class="toc-text">7.12 ONBUILD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-Dockerfile-Examples"><span class="toc-number">7.13.</span> <span class="toc-text">7.13 Dockerfile Examples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-14-docker-build"><span class="toc-number">7.14.</span> <span class="toc-text">7.14 docker build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15-dockerfile-最佳实践"><span class="toc-number">7.15.</span> <span class="toc-text">7.15 dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-指令"><span class="toc-number">7.15.1.</span> <span class="toc-text">Dockerfile 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、容器数据管理"><span class="toc-number">8.</span> <span class="toc-text">八、容器数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-数据卷"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加一个数据卷"><span class="toc-number">8.1.1.</span> <span class="toc-text">添加一个数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂载宿主机目录为一个数据卷"><span class="toc-number">8.1.2.</span> <span class="toc-text">挂载宿主机目录为一个数据卷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-创建和挂载一个数据卷容器"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 创建和挂载一个数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-备份、恢复或迁移数据卷"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 备份、恢复或迁移数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备份"><span class="toc-number">8.3.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复"><span class="toc-number">8.3.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-删除-Volumes"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 删除 Volumes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、链接容器"><span class="toc-number">9.</span> <span class="toc-text">九、链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-容器命名"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 容器命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-链接容器"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量"><span class="toc-number">9.2.1.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新-etc-hosts文件"><span class="toc-number">9.2.2.</span> <span class="toc-text">更新/etc/hosts文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、构建私有库"><span class="toc-number">10.</span> <span class="toc-text">十、构建私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-快速构建"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 快速构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-不使用容器构建-registry"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 不使用容器构建 registry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装必要的软件"><span class="toc-number">10.2.1.</span> <span class="toc-text">安装必要的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-docker-registry"><span class="toc-number">10.2.2.</span> <span class="toc-text">配置 docker-registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行"><span class="toc-number">10.2.3.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级启动方式-不推荐"><span class="toc-number">10.2.4.</span> <span class="toc-text">高级启动方式 [不推荐]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-提交指定容器到私有库"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 提交指定容器到私有库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、docker-启动redis"><span class="toc-number">11.</span> <span class="toc-text">十一、docker 启动redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、docker-部署zookeeper"><span class="toc-number">12.</span> <span class="toc-text">十二、docker 部署zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZK-集群的搭建"><span class="toc-number">13.</span> <span class="toc-text">ZK 集群的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Docker-命令行客户端连接-ZK-集群"><span class="toc-number">13.1.</span> <span class="toc-text">使用 Docker 命令行客户端连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过本地主机连接-ZK-集群"><span class="toc-number">13.2.</span> <span class="toc-text">通过本地主机连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看集群"><span class="toc-number">13.3.</span> <span class="toc-text">查看集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、docker-部署-rabbitmq"><span class="toc-number">14.</span> <span class="toc-text">十三、docker 部署 rabbitmq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-、启动Eureka"><span class="toc-number">15.</span> <span class="toc-text">十四 、启动Eureka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五-、启动Config-Server"><span class="toc-number">16.</span> <span class="toc-text">十五 、启动Config Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六-、启动-mysql"><span class="toc-number">17.</span> <span class="toc-text">十六 、启动 mysql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七、启动nginx"><span class="toc-number">18.</span> <span class="toc-text">十七、启动nginx</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-docker" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Docker 容器技术</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2018/02/12/docker/" class="article-date"><time datetime="2018-02-12T04:15:31.000Z" itemprop="datePublished">2018-02-12</time></a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/docker/">docker</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="/2018/02/12/docker/" class="leancloud_visitors" data-flag-title="Docker 容器技术">0</span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/02/12/docker/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 14.2k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 63(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h2 id="一、Docker-简介"><a href="#一、Docker-简介" class="headerlink" title="一、Docker 简介"></a>一、Docker 简介</h2><p>Docker是一个新的容器化的技术，它轻巧，且易移植。</p><h3 id="Docker-组件与元素"><a href="#Docker-组件与元素" class="headerlink" title="Docker 组件与元素"></a>Docker 组件与元素</h3><p>Docker有三个组件和三个基本元素。</p><p>三个组件分别是：</p><ul><li><code>Docker Client</code> 是用户界面，它支持用户与<code>Docker Daemon</code>之间通信。</li><li><code>Docker Daemon</code>运行于主机上，处理服务请求。</li><li><code>Docker Index</code>是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。</li></ul><p>三个基本要素分别是：</p><ul><li><code>Docker Containers</code>负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。</li><li><code>Docker Images</code>是一个只读模板，用来运行Docker容器。</li><li><code>DockerFile</code>是文件指令集，用来说明如何自动创建Docker镜像。</li></ul><p><img src="http://topweshare.qiniudn.com/1522984222.png?imageMogr2/thumbnail/!70p" alt></p><h3 id="1-1-Docker-守护进程"><a href="#1-1-Docker-守护进程" class="headerlink" title="1.1 Docker 守护进程"></a>1.1 Docker 守护进程</h3><p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p><h3 id="1-2-Docker-客户端"><a href="#1-2-Docker-客户端" class="headerlink" title="1.2 Docker 客户端"></a>1.2 Docker 客户端</h3><p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p><h3 id="1-3-Docker-内部"><a href="#1-3-Docker-内部" class="headerlink" title="1.3 Docker 内部"></a>1.3 Docker 内部</h3><p>要理解 Docker 内部构建，需要理解以下三种部件：</p><ul><li>Docker 镜像 - Docker images</li><li>Docker 仓库 - Docker registeries</li><li>Docker 容器 - Docker containers</li></ul><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><p>docker 的相关安装方法这里不作介绍，具体安装参考 <a href="https://docs.docker.com/installation/" target="_blank" rel="noopener">官档</a></p><p>获取当前 docker 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker version</span><br><span class="line">Client version: 1.3.2</span><br><span class="line">Client API version: 1.15</span><br><span class="line">Go version (client): go1.3.3</span><br><span class="line">Git commit (client): 39fa2fa/1.3.2</span><br><span class="line">OS/Arch (client): linux/amd64</span><br><span class="line">Server version: 1.3.2</span><br><span class="line">Server API version: 1.15</span><br><span class="line">Go version (server): go1.3.3</span><br><span class="line">Git commit (server): 39fa2fa/1.3.2</span><br></pre></td></tr></table></figure><h2 id="三、Docker-基础用法"><a href="#三、Docker-基础用法" class="headerlink" title="三、Docker 基础用法"></a>三、Docker 基础用法</h2><p><a href="https://registry.hub.docker.com/" target="_blank" rel="noopener">Docker HUB</a> : Docker镜像首页，包括官方镜像和其它公开镜像</p><p>因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 <a href="http://opskumu.github.io/docker.cn" target="_blank" rel="noopener">docker.cn</a> 镜像，镜像保持和官方一致，关键是速度块，推荐使用。</p><h3 id="3-1-Search-images"><a href="#3-1-Search-images" class="headerlink" title="3.1 Search images"></a>3.1 Search images</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search ubuntu</span><br></pre></td></tr></table></figure><h3 id="3-2-Pull-images"><a href="#3-2-Pull-images" class="headerlink" title="3.2 Pull images"></a>3.2 Pull images</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu # 获取 ubuntu 官方镜像 $ sudo docker images # 查看当前镜像列表</span><br></pre></td></tr></table></figure><h3 id="3-3-Running-an-interactive-shell"><a href="#3-3-Running-an-interactive-shell" class="headerlink" title="3.3 Running an interactive shell"></a>3.3 Running an interactive shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>docker run - 运行一个容器</li><li>-t - 分配一个（伪）tty (link is external)</li><li>-i - 交互模式 (so we can interact with it)</li><li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li><li>/bin/bash - 运行命令 bash shell</li></ul><p>注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps # 查看当前运行的容器, ps -a 列出当前系统所有的容器 CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6c9129e9df10        ubuntu:14.04        /bin/bash 6 minutes ago       Up 6 minutes                            cranky_babbage</span><br></pre></td></tr></table></figure><h2 id="四、Docker-命令帮助"><a href="#四、Docker-命令帮助" class="headerlink" title="四、Docker 命令帮助"></a>四、Docker 命令帮助</h2><h3 id="4-1-docker-help"><a href="#4-1-docker-help" class="headerlink" title="4.1 docker help"></a>4.1 docker help</h3><h4 id="docker-command"><a href="#docker-command" class="headerlink" title="docker command"></a>docker command</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker   # docker 命令帮助</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line">    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line">    commit    Create a new image from a container&apos;s changes # 提交当前容器为新的镜像</span><br><span class="line">    cp        Copy files/folders from the containers filesystem to the host path</span><br><span class="line">              # 从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line">    diff      Inspect changes on a container&apos;s filesystem   # 查看 docker 容器变化</span><br><span class="line">    exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line">    export    Stream the contents of a container as a tar archive   </span><br><span class="line">              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line">    history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line">    images    List images                                   # 列出系统当前镜像</span><br><span class="line">    import    Create a new filesystem image from the contents of a tarball  </span><br><span class="line">              # 从tar包中的内容创建一个新的文件系统映像[对应 export]</span><br><span class="line">    info      Display system-wide information               # 显示系统相关信息</span><br><span class="line">    inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line">    kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line">    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line">    login     Register or Login to the docker registry server   </span><br><span class="line">              # 注册或者登陆一个 docker 源服务器</span><br><span class="line">    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出</span><br><span class="line">    logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line">    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</span><br><span class="line">              # 查看映射端口对应的容器内部源端口</span><br><span class="line">    pause     Pause all processes within a container        # 暂停容器</span><br><span class="line">    ps        List containers                               # 列出容器列表</span><br><span class="line">    pull      Pull an image or a repository from the docker registry server</span><br><span class="line">              # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">    push      Push an image or a repository to the docker registry server</span><br><span class="line">              # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">    restart   Restart a running container                   # 重启运行的容器</span><br><span class="line">    rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line">    rmi       Remove one or more images                 </span><br><span class="line">              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">    run       Run a command in a new container</span><br><span class="line">              # 创建一个新的容器并运行一个命令</span><br><span class="line">    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line">    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line">    start     Start a stopped containers                    # 启动容器</span><br><span class="line">    stop      Stop a running containers                     # 停止容器</span><br><span class="line">    tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line">    top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line">    unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line">    version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line">    wait      Block until a container stops, then print its exit code   </span><br><span class="line">              # 截取容器停止时的退出状态值</span><br><span class="line">Run &apos;docker COMMAND --help&apos; for more information on a command.</span><br></pre></td></tr></table></figure><h4 id="docker-option"><a href="#docker-option" class="headerlink" title="docker option"></a>docker option</h4><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage of docker:</span><br><span class="line">  --api-enable-cors=<span class="literal">false</span>                Enable CORS headers <span class="keyword">in</span> the remote API                      # 远程 API 中开启 CORS 头</span><br><span class="line">  -b, --bridge=<span class="string">""</span>                        Attach containers to a pre-existing network bridge         # 桥接网络</span><br><span class="line">                                           use 'none' to disable container networking</span><br><span class="line">  --bip=""                               Use this CIDR notation address for the network bridge's IP, not compatible with -b</span><br><span class="line">                                         # 和 -b 选项不兼容，具体没有测试过</span><br><span class="line">  -d, --daemon=<span class="literal">false</span>                     Enable daemon mode                                      # daemon 模式</span><br><span class="line">  -D, --<span class="keyword">debug</span>=<span class="literal">false</span>                      Enable <span class="keyword">debug</span> mode                                            # <span class="keyword">debug</span> 模式</span><br><span class="line">  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器</span><br><span class="line">  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域</span><br><span class="line">  -e, --exec-driver=<span class="string">"native"</span>             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器</span><br><span class="line">  --fixed-cidr=<span class="string">""</span>                        IPv4 subnet <span class="keyword">for</span> fixed IPs (ex: <span class="number">10.20</span>.0.0/<span class="number">16</span>)</span><br><span class="line">                                           <span class="keyword">this</span> subnet must be nested <span class="keyword">in</span> the bridge subnet (which <span class="keyword">is</span> defined by -b or --bip)</span><br><span class="line">  -G, --group=<span class="string">"docker"</span>                   Group to assign the unix socket specified by -H when running <span class="keyword">in</span> daemon mode</span><br><span class="line">                                           use '' (the empty string) to disable setting of a group</span><br><span class="line">  -g, --graph=<span class="string">"/var/lib/docker"</span>          Path to use as the root of the docker runtime              # 容器运行的根目录路径</span><br><span class="line">  -H, --host=[]                          The socket(s) to bind to <span class="keyword">in</span> daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]</span><br><span class="line">                                           specified using one or more tcp:<span class="comment">//host:port, unix:///path/to/socket, fd://* or fd://socketfd.</span></span><br><span class="line">  --icc=<span class="literal">true</span>                             Enable inter-container communication                       # 跨容器通信</span><br><span class="line">  --insecure-registry=[]                 Enable insecure communication <span class="keyword">with</span> specified registries (no certificate verification <span class="keyword">for</span> HTTPS and enable HTTP fallback) (e.g., localhost:<span class="number">5000</span> or <span class="number">10.20</span>.0.0/<span class="number">16</span>)</span><br><span class="line">  --ip=<span class="string">"0.0.0.0"</span>                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip</span><br><span class="line">  --ip-forward=<span class="literal">true</span>                      Enable net.ipv4.ip_forward                                 # 开启转发</span><br><span class="line">  --ip-masq=true                         Enable IP masquerading for bridge's IP range</span><br><span class="line">  --iptables=true                        Enable Docker's addition of iptables rules                 # 添加对应 iptables 规则</span><br><span class="line">  --mtu=<span class="number">0</span>                                Set the containers network MTU                             # 设置网络 mtu</span><br><span class="line">                                           <span class="keyword">if</span> no value <span class="keyword">is</span> provided: <span class="keyword">default</span> to the <span class="keyword">default</span> route MTU or <span class="number">1500</span> <span class="keyword">if</span> no <span class="keyword">default</span> route <span class="keyword">is</span> available</span><br><span class="line">  -p, --pidfile=<span class="string">"/var/run/docker.pid"</span>    Path to use <span class="keyword">for</span> daemon PID file                            # 指定 pid 文件位置</span><br><span class="line">  --registry-mirror=[]                   Specify a preferred Docker registry mirror                  </span><br><span class="line">  -s, --storage-driver=<span class="string">""</span>                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动</span><br><span class="line">  --selinux-enabled=<span class="literal">false</span>                Enable selinux support                                     # 开启 selinux 支持</span><br><span class="line">  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项</span><br><span class="line">  --tls=<span class="literal">false</span>                            Use TLS; implied by tls-verify flags                       # 开启 tls</span><br><span class="line">  --tlscacert=<span class="string">"/root/.docker/ca.pem"</span>     Trust only remotes providing a certificate signed by the CA given here</span><br><span class="line">  --tlscert=<span class="string">"/root/.docker/cert.pem"</span>     Path to TLS certificate file                               # tls 证书文件位置</span><br><span class="line">  --tlskey=<span class="string">"/root/.docker/key.pem"</span>       Path to TLS key file                                       # tls key 文件位置</span><br><span class="line">  --tlsverify=<span class="literal">false</span>                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机</span><br><span class="line">  -v, --<span class="keyword">version</span>=<span class="literal">false</span>                    Print <span class="keyword">version</span> information and quit                         # 输出 docker 版本信息</span><br></pre></td></tr></table></figure><h3 id="4-2-docker-search"><a href="#4-2-docker-search" class="headerlink" title="4.2 docker search"></a>4.2 docker search</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search --help</span><br><span class="line"></span><br><span class="line">Usage: docker search TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images # 从 Docker Hub 搜索镜像 --automated=false Only show automated builds</span><br><span class="line">  --no-trunc=false Don&apos;t truncate output</span><br><span class="line">  -s, --stars=0 Only displays with at least xxx stars</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search -s 100 ubuntu # 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像 NAME      DESCRIPTION                  STARS     OFFICIAL   AUTOMATED</span><br><span class="line">ubuntu    Official Ubuntu base image 425 [OK]</span><br></pre></td></tr></table></figure><h3 id="4-3-docker-info"><a href="#4-3-docker-info" class="headerlink" title="4.3 docker info"></a>4.3 docker info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker info </span><br><span class="line">Containers: 1 # 容器个数 Images: 22 # 镜像个数 Storage Driver: devicemapper # 存储驱动 Pool Name: docker-8:17-3221225728-pool</span><br><span class="line"> Pool Blocksize: 65.54 kB</span><br><span class="line"> Data file: /data/docker/devicemapper/devicemapper/data</span><br><span class="line"> Metadata file: /data/docker/devicemapper/devicemapper/metadata</span><br><span class="line"> Data Space Used: 1.83 GB</span><br><span class="line"> Data Space Total: 107.4 GB</span><br><span class="line"> Metadata Space Used: 2.191 MB</span><br><span class="line"> Metadata Space Total: 2.147 GB</span><br><span class="line"> Library Version: 1.02.84-RHEL7 (2014-03-26) Execution Driver: native-0.2 # 存储驱动 Kernel Version: 3.10.0-123.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br></pre></td></tr></table></figure><h3 id="4-4-docker-pull-amp-amp-docker-push"><a href="#4-4-docker-pull-amp-amp-docker-push" class="headerlink" title="4.4 docker pull &amp;&amp; docker push"></a>4.4 docker pull &amp;&amp; docker push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull --help # pull 拉取镜像 Usage: docker pull [OPTIONS] NAME[:TAG] Pull an image or a repository from the registry</span><br><span class="line"></span><br><span class="line">  -a, --all-tags=false Download all tagged images in the repository $ sudo docker push # push 推送指定镜像 Usage: docker push NAME[:TAG] Push an image or a repository to the registry</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu # 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像 $ sudo docker pull ubuntu:14.04 # 下载指定版本 ubuntu 官方镜像</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.0.100:5000/ubuntu # 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户] $ sudo docker push 192.168.0.100:5000/ubuntu:14.04 # 推送指定镜像到私有源</span><br></pre></td></tr></table></figure><h3 id="4-5-docker-images"><a href="#4-5-docker-images" class="headerlink" title="4.5 docker images"></a>4.5 docker images</h3><p>列出当前系统镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images --help</span><br><span class="line"></span><br><span class="line">Usage: docker images [OPTIONS] [NAME] List images</span><br><span class="line"></span><br><span class="line">  -a, --all=false Show all images (by default filter out the intermediate image layers) # -a 显示当前系统的所有镜像，包括过渡层镜像，默认 docker images 显示最终镜像，不包括过渡层镜像 -f, --filter=[] Provide filter values (i.e. &apos;dangling=true&apos;) --no-trunc=false Don&apos;t truncate output</span><br><span class="line">  -q, --quiet=false Only show numeric IDs</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images # 显示当前系统镜像，不包括过渡层镜像 $ sudo docker images -a # 显示当前系统所有镜像，包括过渡层镜像 $ sudo docker images ubuntu # 显示当前系统 docker ubuntu 库中的所有镜像 REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                     12.04               ebe4be4dd427 4 weeks ago         210.6 MB</span><br><span class="line">ubuntu                     14.04               e54ca5efa2e9 4 weeks ago         276.5 MB</span><br><span class="line">ubuntu                     14.04-ssh           6334d3ac099a 7 weeks ago         383.2 MB</span><br></pre></td></tr></table></figure><h3 id="4-6-docker-rmi"><a href="#4-6-docker-rmi" class="headerlink" title="4.6 docker rmi"></a>4.6 docker rmi</h3><p>删除一个或者多个镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rmi --help</span><br><span class="line"></span><br><span class="line">Usage: docker rmi IMAGE [IMAGE...] Remove one or more images</span><br><span class="line"></span><br><span class="line">  -f, --force=false Force removal of the image # 强制移除镜像不管是否有容器使用该镜像 --no-prune=false Do not delete untagged parents # 不要删除未标记的父镜像 </span><br><span class="line">  </span><br><span class="line">$ sudo docker rm `docker ps -a -q`    !!!批量清除所有容器</span><br></pre></td></tr></table></figure><h3 id="4-7-docker-run"><a href="#4-7-docker-run" class="headerlink" title="4.7 docker run"></a>4.7 docker run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --help</span><br><span class="line"></span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Run a command in a new container</span><br><span class="line"></span><br><span class="line">  -a, --attach=[] Attach to stdin, stdout or stderr.</span><br><span class="line">  -c, --cpu-shares=0 CPU shares (relative weight) # 设置 cpu 使用权重 --cap-add=[] Add Linux capabilities</span><br><span class="line">  --cap-drop=[] Drop Linux capabilities</span><br><span class="line">  --cidfile=&quot;&quot; Write the container ID to the file # 把容器 id 写入到指定文件 </span><br><span class="line">  --cpuset=&quot;&quot; CPUs in which to allow execution (0-3, 0,1) # cpu 绑定 </span><br><span class="line">  -d, --detach=false Detached mode: Run container in the background, print new container id # 后台运行容器 --device=[] Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc) </span><br><span class="line">  --dns=[] Set custom dns servers # 设置 dns --dns-search=[] Set custom dns search domains # 设置 dns 域搜索 </span><br><span class="line">  -e, --env=[] Set environment variables # 定义环境变量 --entrypoint=&quot;&quot; Overwrite the default entrypoint of the image # ？ </span><br><span class="line">  --env-file=[] Read in a line delimited file of ENV variables # 从指定文件读取变量值 --expose=[] Expose a port from the container without publishing it to your host # 指定对外提供服务端口 </span><br><span class="line">  -h, --hostname=&quot;&quot; Container host name # 设置容器主机名 </span><br><span class="line">  -i, --interactive=false Keep stdin open even if not attached # 保持标准输出开启即使没有 attached --link=[] Add link to another container (name:alias) # 添加链接到另外一个容器 --lxc-conf=[] (lxc exec-driver only) Add custom lxc options --lxc-conf=&quot;lxc.cgroup.cpuset.cpus = 0,1&quot; </span><br><span class="line">  -m, --memory=&quot;&quot; Memory limit (format: &lt;number&gt;&lt;optional unit&gt;, where unit = b, k, m or g) # 内存限制 </span><br><span class="line">  --name=&quot;&quot; Assign a name to the container # 设置容器名 </span><br><span class="line">  --net=&quot;bridge&quot; Set the Network mode for the container # 设置容器网络模式 &apos;bridge&apos;: creates a new network stack for the container on the docker bridge &apos;none&apos;: no networking for this container &apos;container:&lt;name|id&gt;&apos;: reuses another container network stack &apos;host&apos;: use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.</span><br><span class="line">  -P, --publish-all=false Publish all exposed ports to the host interfaces # 自动映射容器对外提供服务的端口 -p, --publish=[] Publish a container&apos;s port to the host             # 指定端口映射  format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort  (use &apos;docker port&apos; to see the actual mapping) </span><br><span class="line">  --privileged=false Give extended privileges to this container # 提供更多的权限给容器 --restart=&quot;&quot; Restart policy to apply when a container exits (no, on-failure[:max-retry], always) </span><br><span class="line">  --rm=false Automatically remove the container when it exits (incompatible with -d) # 如果容器退出自动移除和 -d 选项冲突 --security-opt=[] Security Options</span><br><span class="line">  --sig-proxy=true Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied.</span><br><span class="line">  -t, --tty=false Allocate a pseudo-tty # 分配伪终端 </span><br><span class="line">  -u, --user=&quot;&quot; Username or UID # 指定运行容器的用户 uid 或者用户名</span><br><span class="line">  -v, --volume=[] Bind mount a volume (e.g., from the host: -v /host:/container, from docker: -v /container) # 挂载卷 --volumes-from=[] Mount volumes from the specified container(s) # 从指定容器挂载卷 </span><br><span class="line">  -w, --workdir=&quot;&quot; Working directory inside the container # 指定容器工作目录</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu              14.04               e54ca5efa2e9 4 weeks ago         276.5 MB</span><br><span class="line">... ... </span><br><span class="line">$ sudo docker run -t -i -c 100 -m 512MB -h test1 -d --name=&quot;docker_test1&quot; ubuntu /bin/bash # 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器 a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5 </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES</span><br><span class="line">a424ca613c9f        ubuntu:14.04    /bin/bash 6 seconds ago       Up 5 seconds                    docker_test1 </span><br><span class="line">$ sudo docker attach docker_test1</span><br><span class="line">root@test1:/# pwd /</span><br><span class="line">root@test1:/# exit exit</span><br></pre></td></tr></table></figure><h3 id="4-8-docker-start-stop-kill…-…"><a href="#4-8-docker-start-stop-kill…-…" class="headerlink" title="4.8 docker start|stop|kill… …"></a>4.8 docker start|stop|kill… …</h3><p>dockerstart|stop|kill|restart|pause|unpause|rm|commit|inspect|logs</p><ul><li><p>docker start CONTAINER [CONTAINER…]</p><ul><li># 运行一个或多个停止的容器</li></ul></li><li><p>docker stop CONTAINER [CONTAINER…]</p><p>​</p><ul><li># 停掉一个或多个运行的容器-t选项可指定超时时间</li></ul></li><li><p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p><ul><li># 默认 kill 发送 SIGKILL 信号-s可以指定发送 kill 信号类型</li></ul></li><li><p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p><ul><li># 重启一个或多个运行的容器-t选项可指定超时时间</li></ul></li><li><p>docker pause CONTAINER</p><ul><li># 暂停一个容器，方便 commit</li></ul></li><li><p>docker unpause CONTAINER</p><ul><li># 继续暂停的容器</li></ul></li><li><p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p><p>​</p><ul><li># 移除一个或多个容器</li><li>-f, –force=false Force removal of running container</li><li>-l, –link=false Remove the specified link and not the underlying container</li><li>-v, –volumes=false Remove the volumes associated with the container</li></ul></li><li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>​</p><ul><li># 提交指定容器为镜像</li><li>-a, –author=”” Author (e.g., “John Hannibal Smith <a href="mailto:hannibal@a-team.com" target="_blank" rel="noopener">hannibal@a-team.com</a>“)</li><li>-m, –message=”” Commit message</li><li>-p, –pause=true Pause container during commit<ul><li># 默认 commit 是暂停状态</li></ul></li></ul></li><li><p>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE…]</p><p>​</p><ul><li># 查看容器或者镜像的详细信息</li></ul></li><li><p>docker logs CONTAINER</p><ul><li># 输出指定容器日志信息</li><li>-f, –follow=false Follow log output<ul><li># 类似 tail -f</li></ul></li><li>-t, –timestamps=false Show timestamps</li><li>–tail=”all” Output the specified number of lines at the end of logs (defaults to all logs)</li></ul></li></ul><p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener">Docker Run Reference</a></p><h2 id="五、Docker-端口映射"><a href="#五、Docker-端口映射" class="headerlink" title="五、Docker 端口映射"></a>五、Docker 端口映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip </span><br><span class="line">$ sudo docker inspect &lt;container_id&gt; | grep IPAddress | cut -d ’&quot;’ -f 4</span><br></pre></td></tr></table></figure><p>无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。</p><p>Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。</p><h3 id="5-1-自动映射端口"><a href="#5-1-自动映射端口" class="headerlink" title="5.1 自动映射端口"></a>5.1 自动映射端口</h3><p>-P使用时需要指定–expose选项，指定需要对外提供服务的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -P --expose 22 --name server  ubuntu:14.04</span><br></pre></td></tr></table></figure><p>使用docker run -P自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000..49900) 自动选择，你可以通过docker ps、docker inspect &lt;container_id&gt;或者docker port &lt;container_id&gt;<port>确定具体的绑定信息。</port></p><h3 id="5-2-绑定端口到指定接口"><a href="#5-2-绑定端口到指定接口" class="headerlink" title="5.2 绑定端口到指定接口"></a>5.2 绑定端口到指定接口</h3><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;</span><br></pre></td></tr></table></figure><p>默认不指定绑定 ip 则监听所有网络接口。</p><h4 id="绑定-TCP-端口"><a href="#绑定-TCP-端口" class="headerlink" title="绑定 TCP 端口"></a>绑定 TCP 端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine. </span><br><span class="line">$ sudo docker run -p 127.0.0.1:80:8080 &lt;image&gt; &lt;cmd&gt; # Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine. </span><br><span class="line">$ sudo docker run -p 127.0.0.1::8080 &lt;image&gt; &lt;cmd&gt; # Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine. </span><br><span class="line">$ sudo docker run -p 80:8080 &lt;image&gt; &lt;cmd&gt; # Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces</span><br><span class="line">$ sudo docker run -p 8080 &lt;image&gt; &lt;cmd&gt;</span><br></pre></td></tr></table></figure><h4 id="绑定-UDP-端口"><a href="#绑定-UDP-端口" class="headerlink" title="绑定 UDP 端口"></a>绑定 UDP 端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine. </span><br><span class="line">$ sudo docker run -p 127.0.0.1:53:5353/udp &lt;image&gt; &lt;cmd&gt;</span><br></pre></td></tr></table></figure><h2 id="六、Docker-网络配置"><a href="#六、Docker-网络配置" class="headerlink" title="六、Docker 网络配置"></a>六、Docker 网络配置</h2><p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091034_634.png" alt="非常详细的 Docker 学习笔记"></p><p>图: <a href="http://www.slideshare.net/janghoonsim/docker-container-and-lightweight-virtualization" target="_blank" rel="noopener">Docker - container and lightweight virtualization</a></p><p>Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：</p><ul><li>creates the docker0 bridge if not present<ul><li># 如果 docker0 不存在则创建</li></ul></li><li>searches for an IP address range which doesn’t overlap with an existing route<ul><li># 搜索一个与当前路由不冲突的 ip 段</li></ul></li><li>picks an IP in the selected range<ul><li># 在确定的范围中选择 ip</li></ul></li><li>assigns this IP to the docker0 bridge<ul><li># 绑定 ip 到 docker0</li></ul></li></ul><h3 id="6-1-Docker-四种网络模式"><a href="#6-1-Docker-四种网络模式" class="headerlink" title="6.1 Docker 四种网络模式"></a>6.1 Docker 四种网络模式</h3><p>四种网络模式摘自 <a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener">Docker 网络详解及 pipework 源码解读与实践</a></p><p>docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p><ul><li>host 模式，使用 –net=host 指定。</li><li>container 模式，使用 –net=container:NAMEorID 指定。</li><li>none 模式，使用 –net=none 指定。</li><li>bridge 模式，使用 –net=bridge 指定，默认设置。</li></ul><h4 id="host-模式"><a href="#host-模式" class="headerlink" title="host 模式"></a>host 模式</h4><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p><p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><h4 id="container-模式"><a href="#container-模式" class="headerlink" title="container 模式"></a>container 模式</h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_252.png" alt="非常详细的 Docker 学习笔记"></p><p>图:<a href="http://www.wickedawesometech.us/2014/07/the-container-world-part-2-networking.html" target="_blank" rel="noopener">The Container World | Part 2 Networking</a></p><p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p><h3 id="6-2-列出当前主机网桥"><a href="#6-2-列出当前主机网桥" class="headerlink" title="6.2 列出当前主机网桥"></a>6.2 列出当前主机网桥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl show # brctl 工具依赖 bridge-utils 软件包 bridge name bridge id STP enabled interfaces</span><br><span class="line">docker0 8000.000000000000 no</span><br></pre></td></tr></table></figure><h3 id="6-3-查看当前-docker0-ip"><a href="#6-3-查看当前-docker0-ip" class="headerlink" title="6.3 查看当前 docker0 ip"></a>6.3 查看当前 docker0 ip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig docker0</span><br><span class="line">docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx</span><br><span class="line">inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0</span><br></pre></td></tr></table></figure><p>在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。</p><h3 id="6-4-运行一个容器"><a href="#6-4-运行一个容器" class="headerlink" title="6.4 运行一个容器"></a>6.4 运行一个容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d ubuntu /bin/bash</span><br><span class="line">52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4</span><br><span class="line">$ sudo brctl show</span><br><span class="line">bridge name bridge id STP enabled interfaces</span><br><span class="line">docker0 8000.fef213db5a66 no vethQCDY1N</span><br></pre></td></tr></table></figure><p>以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。</p><h4 id="使用特定范围的-IP"><a href="#使用特定范围的-IP" class="headerlink" title="使用特定范围的 IP"></a>使用特定范围的 IP</h4><p>Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过-b选项自定义桥接网卡，需要安装bridge-utils软件包。</p><p>基本步骤如下：</p><ul><li><p>ensure Docker is stopped</p><p>​</p><ul><li># 确保 docker 的进程是停止的</li></ul></li><li><p>create your own bridge (bridge0 for example)</p><ul><li># 创建自定义网桥</li></ul></li><li><p>assign a specific IP to this bridge</p><p>​</p><ul><li># 给网桥分配特定的 ip</li></ul></li><li><p>start Docker with the -b=bridge0 parameter</p><ul><li># 以 -b 的方式指定网桥</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Stopping Docker and removing docker0 $ sudo service docker stop $ sudo ip link set dev docker0 down $ sudo brctl delbr docker0 # Create our own bridge $ sudo brctl addbr bridge0 $ sudo ip addr add 192.168.5.1/24 dev bridge0 $ sudo ip link set dev bridge0 up # Confirming that our bridge is up and running $ ip addr show bridge0</span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever # Tell Docker about it and restart (on Ubuntu) $ echo &apos;DOCKER_OPTS=&quot;-b=bridge0&quot;&apos; &gt;&gt; /etc/default/docker $ sudo service docker start</span><br></pre></td></tr></table></figure><p>参考文档: <a href="https://docs.docker.com/articles/networking/" target="_blank" rel="noopener">Network Configuration</a></p><h3 id="6-5-不同主机间容器通信"><a href="#6-5-不同主机间容器通信" class="headerlink" title="6.5 不同主机间容器通信"></a>6.5 不同主机间容器通信</h3><p>不同容器之间的通信可以借助于 pipework 这个工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/jpetazzo/pipework.git</span><br><span class="line">$ sudo cp -rp pipework/pipework /usr/local/bin/</span><br></pre></td></tr></table></figure><h4 id="安装相应依赖软件"><a href="#安装相应依赖软件" class="headerlink" title="安装相应依赖软件"></a>安装相应依赖软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install iputils-arping bridge-utils -y</span><br></pre></td></tr></table></figure><h4 id="桥接网络"><a href="#桥接网络" class="headerlink" title="桥接网络"></a>桥接网络</h4><p>桥接网络可以参考 <a href="https://github.com/opskumu/Day/blob/master/tips/tips.md" target="_blank" rel="noopener">日常问题处理 Tips</a> 关于桥接的配置说明，这里不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.000c291412cd       no              eth0</span><br><span class="line">docker0         8000.56847afe9799       no              vetheb48029</span><br></pre></td></tr></table></figure><p>可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。</p><ul><li>ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker stop</span><br><span class="line">$ sudo ip link set dev docker0 down</span><br><span class="line">$ sudo brctl delbr docker0</span><br><span class="line">$ echo &apos;DOCKER_OPTS=&quot;-b=br0&quot;&apos; &gt;&gt; /etc/default/docker</span><br><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure><ul><li>CentOS 7/RHEL 7</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br><span class="line">$ sudo ip link set dev docker0 down</span><br><span class="line">$ sudo brctl delbr docker0</span><br><span class="line">$ cat /etc/sysconfig/docker | grep &apos;OPTIONS=&apos;</span><br><span class="line">OPTIONS=--selinux-enabled -b=br0 -H fd://</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="pipework"><a href="#pipework" class="headerlink" title="pipework"></a>pipework</h4><p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_900.png" alt="非常详细的 Docker 学习笔记"></p><p>不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/jpetazzo/pipework.git</span><br><span class="line">$ sudo cp -rp pipework/pipework /usr/local/bin/</span><br><span class="line">$ pipework </span><br><span class="line">Syntax:</span><br><span class="line">pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; &lt;ipaddr&gt;/&lt;subnet&gt;[@default_gateway] [macaddr][@vlan]</span><br><span class="line">pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; dhcp [macaddr][@vlan]</span><br><span class="line">pipework --wait [-i containerinterface]</span><br></pre></td></tr></table></figure><p>如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上–net=none，防止自动分配的 IP 在局域网中有冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -ti --net=none ubuntu:14.04 /bin/bash</span><br><span class="line">root@a46657528059:/#</span><br><span class="line">$                  # Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态</span><br><span class="line">$ sudo docker  ps</span><br><span class="line">CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES</span><br><span class="line">a46657528059    ubuntu:14.04   &quot;/bin/bash&quot;   4 minutes ago   Up 4 minutes               hungry_lalande</span><br><span class="line">$ sudo pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2 </span><br><span class="line"># 默认不指定网卡设备名，则默认添加为 eth1</span><br><span class="line"># 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=true 权限在容器中手动添加，</span><br><span class="line"># 但这种安全性有缺陷，可以通过 ip netns 操作</span><br><span class="line">$ sudo docker attach a46657528059</span><br><span class="line">root@a46657528059:/# ifconfig eth0</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d  </span><br><span class="line">          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:690 (690.0 B)</span><br><span class="line"></span><br><span class="line">root@a46657528059:/# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><p>使用ip netns添加静态路由，避免创建容器使用–privileged=true选项造成一些不必要的安全问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=&quot;&#123;&#123; .State.Pid &#125;&#125;&quot; a46657528059 # 获取指定容器 pid</span><br><span class="line">6350</span><br><span class="line">$ sudo ln -s /proc/6350/ns/net /var/run/netns/6350</span><br><span class="line">$ sudo ip netns exec 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2</span><br><span class="line">$ sudo ip netns exec 6350 ip route    # 添加成功</span><br><span class="line">192.168.0.0/16 via 192.168.115.2 dev eth0 </span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。</p><p>另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：</p><ul><li><a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">Pipework 官方文档</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener">Docker 网络详解及 pipework 源码解读与实践</a></li></ul><h2 id="七、Dockerfile"><a href="#七、Dockerfile" class="headerlink" title="七、Dockerfile"></a>七、Dockerfile</h2><p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过docker build命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p><p>Dockerfile 有以下指令选项:</p><ul><li>FROM</li><li>MAINTAINER</li><li>RUN</li><li>CMD</li><li>EXPOSE</li><li>ENV</li><li>ADD</li><li>COPY</li><li>ENTRYPOINT</li><li>VOLUME</li><li>USER</li><li>WORKDIR</li><li>ONBUILD</li></ul><h3 id="7-1-FROM"><a href="#7-1-FROM" class="headerlink" title="7.1 FROM"></a>7.1 FROM</h3><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><ul><li>FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li><li>FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始。</li><li>FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。</li><li>如果FROM语句没有指定镜像标签，则默认使用latest标签。</li></ul><h3 id="7-2-MAINTAINER"><a href="#7-2-MAINTAINER" class="headerlink" title="7.2 MAINTAINER"></a>7.2 MAINTAINER</h3><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>指定创建镜像的用户</p><p>RUN 有两种使用方式</p><ul><li>RUN</li><li>RUN <a href="http://opskumu.github.io/exec%20form" target="_blank" rel="noopener">“executable”, “param1”, “param2”</a></li></ul><p>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。</p><p>exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure><p>RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build –no-cache，如此便不会缓存。</p><h3 id="7-3-CMD"><a href="#7-3-CMD" class="headerlink" title="7.3 CMD"></a>7.3 CMD</h3><p>CMD有三种使用方式:</p><ul><li>CMD <a href="http://opskumu.github.io/exec%20form,%20this%20is%20the%20preferred%20form,%20%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">“executable”,”param1”,”param2”</a></li><li>CMD <a href="http://opskumu.github.io/as%20default%20parameters%20to%20%60ENTRYPOINT%60" target="_blank" rel="noopener">“param1”,”param2”</a></li><li>CMD command param1 param2 (shell form)</li></ul><p>CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p><p>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p><blockquote><p>CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p></blockquote><h3 id="7-4-EXPOSE"><a href="#7-4-EXPOSE" class="headerlink" title="7.4 EXPOSE"></a>7.4 EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。</p><h3 id="7-5-ENV"><a href="#7-5-ENV" class="headerlink" title="7.5 ENV"></a>7.5 ENV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量</span><br></pre></td></tr></table></figure><p>指定一个环节变量，会被后续RUN指令使用，并在容器运行时保留。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br></pre></td></tr></table></figure><h3 id="7-6-ADD"><a href="#7-6-ADD" class="headerlink" title="7.6 ADD"></a>7.6 ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。</p><p>支持通过 GO 的正则模糊匹配，具体规则可参见 <a href="http://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">Go filepath.Match</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD hom* /mydir/        # adds all files starting with &quot;hom&quot;</span><br><span class="line">ADD hom?.txt /mydir/    # ? is replaced with any single character</span><br></pre></td></tr></table></figure><ul><li>路径必须是绝对路径，如果 不存在，会自动创建对应目录</li><li>路径必须是 Dockerfile 所在路径的相对路径</li><li>如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li></ul><h3 id="7-7-COPY"><a href="#7-7-COPY" class="headerlink" title="7.7 COPY"></a>7.7 COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</p><h3 id="7-8-ENTRYPOINT"><a href="#7-8-ENTRYPOINT" class="headerlink" title="7.8 ENTRYPOINT"></a>7.8 ENTRYPOINT</h3><ul><li>ENTRYPOINT <a href="http://opskumu.github.io/the%20preferred%20exec%20form%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">“executable”, “param1”, “param2”</a></li><li>ENTRYPOINT command param1 param2 (shell form)</li></ul><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用docker run –entrypoint选项。</p><p>每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</p><h4 id="Exec-form-ENTRYPOINT-例子"><a href="#Exec-form-ENTRYPOINT-例子" class="headerlink" title="Exec form ENTRYPOINT 例子"></a>Exec form ENTRYPOINT 例子</h4><p>通过ENTRYPOINT使用 exec form 方式设置稳定的默认命令和选项，而使用CMD添加默认之外经常被改动的选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br></pre></td></tr></table></figure><p>通过 Dockerfile 使用ENTRYPOINT展示前台运行 Apache 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stable</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span><br><span class="line">EXPOSE 80 443</span><br><span class="line">VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure><h4 id="Shell-form-ENTRYPOINT-例子"><a href="#Shell-form-ENTRYPOINT-例子" class="headerlink" title="Shell form ENTRYPOINT 例子"></a>Shell form ENTRYPOINT 例子</h4><p>这种方式会在/bin/sh -c中执行，会忽略任何CMD或者docker run命令行选项，为了确保docker stop能够停止长时间运行ENTRYPOINT的容器，确保执行的时候使用exec选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT exec top -b</span><br></pre></td></tr></table></figure><p>如果在ENTRYPOINT忘记使用exec选项，则可以使用CMD补上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT top -b</span><br><span class="line">CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推</span><br></pre></td></tr></table></figure><h3 id="7-9-VOLUME"><a href="#7-9-VOLUME" class="headerlink" title="7.9 VOLUME"></a>7.9 VOLUME</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p><h3 id="7-10-USER"><a href="#7-10-USER" class="headerlink" title="7.10 USER"></a>7.10 USER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p><h3 id="7-11-WORKDIR"><a href="#7-11-WORKDIR" class="headerlink" title="7.11 WORKDIR"></a>7.11 WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>最终路径是/a/b/c。</p><p>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure><p>最终路径则为 /path/$DIRNAME。</p><h3 id="7-12-ONBUILD"><a href="#7-12-ONBUILD" class="headerlink" title="7.12 ONBUILD"></a>7.12 ONBUILD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p><p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Automatically run the following</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><p>使用ONBUILD指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p><h3 id="7-13-Dockerfile-Examples"><a href="#7-13-Dockerfile-Examples" class="headerlink" title="7.13 Dockerfile Examples"></a>7.13 Dockerfile Examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># Nginx</span><br><span class="line">#</span><br><span class="line"># VERSION               0.0.1</span><br><span class="line"></span><br><span class="line">FROM      ubuntu</span><br><span class="line">MAINTAINER Victor Vieux &lt;victor@docker.com&gt;</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span><br><span class="line"></span><br><span class="line"># Firefox over VNC</span><br><span class="line">#</span><br><span class="line"># VERSION               0.3</span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"># Install vnc, xvfb in order to create a &apos;fake&apos; display and firefox</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span><br><span class="line">RUN mkdir ~/.vnc</span><br><span class="line"># Setup a password</span><br><span class="line">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span><br><span class="line"># Autostart firefox (might not be the best way, but it does the trick)</span><br><span class="line">RUN bash -c &apos;echo &quot;firefox&quot; &gt;&gt; /.bashrc&apos;</span><br><span class="line"></span><br><span class="line">EXPOSE 5900</span><br><span class="line">CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span><br><span class="line"></span><br><span class="line"># Multiple images example</span><br><span class="line">#</span><br><span class="line"># VERSION               0.1</span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo foo &gt; bar</span><br><span class="line"># Will output something like ===&gt; 907ad6c2736f</span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo moo &gt; oink</span><br><span class="line"># Will output something like ===&gt; 695d7793cbe4</span><br><span class="line"></span><br><span class="line"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span><br><span class="line"># /oink.</span><br></pre></td></tr></table></figure><h3 id="7-14-docker-build"><a href="#7-14-docker-build" class="headerlink" title="7.14 docker build"></a>7.14 docker build</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --help</span><br><span class="line"></span><br><span class="line">Usage: docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build a new image from the source code at PATH</span><br><span class="line"></span><br><span class="line">  --force-rm=false     Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败</span><br><span class="line">  --no-cache=false     Do not use cache when building the image                              # 不实用 cache        </span><br><span class="line">  -q, --quiet=false    Suppress the verbose output generated by the containers               </span><br><span class="line">  --rm=true            Remove intermediate containers after a successful build               # 构建成功后移除过渡层容器</span><br><span class="line">  -t, --tag=&quot;&quot;         Repository name (and optionally a tag) to be applied to the resulting image in case of success</span><br></pre></td></tr></table></figure><p>参考文档:<a href="https://docs.docker.com/reference/builder/" target="_blank" rel="noopener">Dockerfile Reference</a></p><h3 id="7-15-dockerfile-最佳实践"><a href="#7-15-dockerfile-最佳实践" class="headerlink" title="7.15 dockerfile 最佳实践"></a>7.15 dockerfile 最佳实践</h3><ul><li>使用.dockerignore文件</li></ul><p>为了在docker build过程中更快上传和更加高效，应该使用一个.dockerignore文件用来排除构建镜像时不需要的文件或目录。例如,除非.git在构建过程中需要用到，否则你应该将它添加到.dockerignore文件中，这样可以节省很多时间。</p><ul><li>避免安装不必要的软件包</li></ul><p>为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。</p><ul><li>每个容器都跑一个进程</li></ul><p>在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank" rel="noopener">Linking Containers Together</a>。</p><ul><li>最小化层</li></ul><p>我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于Dockerfile，应该找到可读性和最小化层之间的平衡。</p><ul><li>多行参数排序</li></ul><p>如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用\换行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure><ul><li>创建缓存</li></ul><p>镜像构建过程中会按照Dockerfile的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在docker build时添加–no-cache=true选项。</p><p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比Dockerfile指令和子镜像就足够了。ADD和COPY指令除外，执行ADD和COPY时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。RUN apt-get -y update命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p><blockquote><p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p></blockquote><h4 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h4><ul><li>FROM: 只要可能就使用官方镜像库作为基础镜像</li><li>RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的RUN语句使用\分隔符分成多行<ul><li>不建议RUN apt-get update独立成行，否则如果后续包有更新，那么也不会再执行更新</li><li>避免使用RUN apt-get upgrade或者dist-upgrade，很多必要的包在一个非privileged权限的容器里是无法升级的。如果知道某个包更新，使用apt-get install -y xxx</li><li>标准写法<ul><li>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</li></ul></li></ul></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    aufs-tools \</span><br><span class="line">    automake \</span><br><span class="line">    btrfs-tools \</span><br><span class="line">    build-essential \</span><br><span class="line">    curl \</span><br><span class="line">    dpkg-sig \</span><br><span class="line">    git \</span><br><span class="line">    iptables \</span><br><span class="line">    libapparmor-dev \</span><br><span class="line">    libcap-dev \</span><br><span class="line">    libsqlite3-dev \</span><br><span class="line">    lxc=1.0* \</span><br><span class="line">    mercurial \</span><br><span class="line">    parallel \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1.9.1 \</span><br><span class="line">    ruby1.9.1-dev \</span><br><span class="line">    s3cmd=1.1.0*</span><br></pre></td></tr></table></figure><ul><li>CMD: 推荐使用CMD [“executable”, “param1”, “param2”…]这种格式，CMD [“param”, “param”]则配合ENTRYPOINT使用</li><li>EXPOSE: Dockerfile 指定要公开的端口，使用docker run时指定映射到宿主机的端口即可</li><li>ENV: 为了使新的软件更容易运行，可以使用ENV更新PATH变量。如ENV PATH /usr/local/nginx/bin:$PATH确保CMD [“nginx”]即可运行</li></ul><p>ENV也可以这样定义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><ul><li>ADDorCOPY:ADD比COPY多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li></ul><p>如不推荐这种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p>推荐使用 curl 或者 wget 替换，使用如下方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /usr/src/things \</span><br><span class="line">    &amp;&amp; curl -SL http://example.com/big.tar.gz \</span><br><span class="line">    | tar -xJC /usr/src/things \</span><br><span class="line">    &amp;&amp; make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p>如果不需要添加 tar 文件，推荐使用COPY。</p><p>参考文档:</p><ul><li><a href="https://docs.docker.com/articles/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li><li><a href="http://dockerone.com/article/131" target="_blank" rel="noopener">Dockerfile最佳实践（一）</a></li><li><a href="http://dockerone.com/article/132" target="_blank" rel="noopener">Dockerfile最佳实践（二）</a></li></ul><h2 id="八、容器数据管理"><a href="#八、容器数据管理" class="headerlink" title="八、容器数据管理"></a>八、容器数据管理</h2><p>docker管理数据的方式有两种：</p><ul><li>数据卷</li><li>数据卷容器</li></ul><h3 id="8-1-数据卷"><a href="#8-1-数据卷" class="headerlink" title="8.1 数据卷"></a>8.1 数据卷</h3><p>数据卷是一个或多个容器专门指定绕过Union File System的目录，为持续性或共享数据提供一些有用的功能：</p><ul><li>数据卷可以在容器间共享和重用</li><li>数据卷数据改变是直接修改的</li><li>数据卷数据改变不会被包括在容器中</li><li>数据卷是持续性的，直到没有容器使用它们</li></ul><h4 id="添加一个数据卷"><a href="#添加一个数据卷" class="headerlink" title="添加一个数据卷"></a>添加一个数据卷</h4><p>你可以使用-v选项添加一个数据卷，或者可以使用多次-v选项为一个 docker 容器运行挂载多个数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash # 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷 bash-4.1# ls -ld /data/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/</span><br><span class="line">bash-4.1# df -Th</span><br><span class="line">Filesystem    Type    Size  Used Avail Use% Mounted on</span><br><span class="line">... ...</span><br><span class="line">              ext4     91G  4.6G   82G   6% /data</span><br></pre></td></tr></table></figure><p>创建的数据卷可以通过docker inspect获取宿主机对应路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect data</span><br><span class="line">... ... &quot;Volumes&quot;: &#123; &quot;/data&quot;: &quot;/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9&quot; &#125;, # 可以看到创建的数据卷宿主机路径 ... ...</span><br></pre></td></tr></table></figure><p>或者直接指定获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=&quot;&#123;&#123; .Volumes &#125;&#125;&quot; data</span><br><span class="line">map[/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9]</span><br></pre></td></tr></table></figure><h4 id="挂载宿主机目录为一个数据卷"><a href="#挂载宿主机目录为一个数据卷" class="headerlink" title="挂载宿主机目录为一个数据卷"></a>挂载宿主机目录为一个数据卷</h4><p>-v选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name web -v /source/:/web -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">bash-4.1# ls -ld /web/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/</span><br><span class="line">bash-4.1# df -Th</span><br><span class="line">... ...</span><br><span class="line">              ext4     91G  4.6G   82G   6% /web</span><br><span class="line">bash-4.1# exit</span><br></pre></td></tr></table></figure><p>默认挂载卷是可读写的，可以在挂载时指定只读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name test -v /source/:/test:ro -t -i ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="8-2-创建和挂载一个数据卷容器"><a href="#8-2-创建和挂载一个数据卷容器" class="headerlink" title="8.2 创建和挂载一个数据卷容器"></a>8.2 创建和挂载一个数据卷容器</h3><p>如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。</p><p>创建数据卷容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d -v /test --name test ubuntu:14.04 echo hello</span><br></pre></td></tr></table></figure><p>使用–volumes-from选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d --volumes-from test --name test1 ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>添加另一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d --volumes-from test --name test2 ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>也可以继承其它挂载有 /test 卷的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_912.png" alt="非常详细的 Docker 学习笔记"></p><h3 id="8-3-备份、恢复或迁移数据卷"><a href="#8-3-备份、恢复或迁移数据卷" class="headerlink" title="8.3 备份、恢复或迁移数据卷"></a>8.3 备份、恢复或迁移数据卷</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --volumes-from test -v $(pwd):/backup ubuntu:14.04 tar cvf /backup/test.tar /test</span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/test/</span><br><span class="line">/test/b</span><br><span class="line">/test/d</span><br><span class="line">/test/c</span><br><span class="line">/test/a</span><br></pre></td></tr></table></figure><p>启动一个新的容器并且从test容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份 test 卷中所有的数据为 test.tar，执行完成之后删除容器–rm，此时备份就在当前的目录下，名为test.tar。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls # 宿主机当前目录下产生了 test 卷的备份文件 test.tar test.tar</span><br></pre></td></tr></table></figure><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i -d -v /test --name test4 ubuntu:14.04  /bin/bash $ sudo docker run --rm --volumes-from test4 -v $(pwd):/backup ubuntu:14.04 tar xvf /backup/test.tar -C / # 恢复之前的文件到新建卷中，执行完后自动删除容器 test/ test/b test/d test/c test/a</span><br></pre></td></tr></table></figure><h3 id="8-4-删除-Volumes"><a href="#8-4-删除-Volumes" class="headerlink" title="8.4 删除 Volumes"></a>8.4 删除 Volumes</h3><p>Volume 只有在下列情况下才能被删除：</p><ul><li>docker rm -v删除容器时添加了-v选项</li><li>docker run –rm运行容器时添加了–rm选项</li></ul><p>否则，会在/var/lib/docker/vfs/dir目录中遗留很多不明目录。</p><p>参考文档：</p><ul><li><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes" target="_blank" rel="noopener">Managing Data in Containers</a></li><li><a href="http://dockerone.com/article/128" target="_blank" rel="noopener">深入理解Docker Volume（一）</a></li><li><a href="http://dockerone.com/article/129" target="_blank" rel="noopener">深入理解Docker Volume（二）</a></li></ul><h2 id="九、链接容器"><a href="#九、链接容器" class="headerlink" title="九、链接容器"></a>九、链接容器</h2><p>docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。</p><h3 id="9-1-容器命名"><a href="#9-1-容器命名" class="headerlink" title="9.1 容器命名"></a>9.1 容器命名</h3><p>在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：</p><ul><li>1、给容器命名方便记忆，如命名运行 web 应用的容器为 web</li><li>2、为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db</li></ul><p>可以通过–name选项给容器自定义命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -t -i --name test ubuntu:14.04 bash              </span><br><span class="line">$ sudo docker  inspect --format=&quot;&#123;&#123; .Nmae &#125;&#125;&quot; test</span><br><span class="line">/test</span><br></pre></td></tr></table></figure><blockquote><p>注：容器名称必须唯一，即你只能命名一个叫test的容器。如果你想复用容器名，则必须在创建新的容器前通过docker rm删除旧的容器或者创建容器时添加–rm选项。</p></blockquote><h3 id="9-2-链接容器"><a href="#9-2-链接容器" class="headerlink" title="9.2 链接容器"></a>9.2 链接容器</h3><p>链接允许容器间安全通信，使用–link选项创建链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure><p>基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>–link<name or>:alias选项指定链接到的容器。</name></p><p>查看 web 容器的链接关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f &quot;&#123;&#123; .HostConfig.Links &#125;&#125;&quot; web</span><br><span class="line">[/db:/web/db]</span><br></pre></td></tr></table></figure><p>可以看到 web 容器被链接到 db 容器为/web/db，这允许 web 容器访问 db 容器的信息。</p><p>容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加-p或-P指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。</p><p>Docker 主要通过以下两个方式提供连接信息给接收容器：</p><ul><li>环境变量</li><li>更新/etc/hosts文件</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。</p><p>首先，Docker 会在每个通过–link选项指定别名的目标容器上设置一个<alias>_NAME环境变量。如果一个名为 web 的容器通过–link db:webdb被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为WEBDB_NAME=/web/webdb.</alias></p><p>以之前的为例，Docker 还会设置端口变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training/webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME=/web2/db</span><br><span class="line">DB_PORT=tcp://172.17.0.5:5432           </span><br><span class="line">DB_PORT_5432_TCP=tcp://172.17.0.5:5432  # &lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt; 协议可以是 TCP 或 UDP</span><br><span class="line">DB_PORT_5432_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_5432_TCP_PORT=5432</span><br><span class="line">DB_PORT_5432_TCP_ADDR=172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><blockquote><p>注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量</p></blockquote><h4 id="更新-etc-hosts文件"><a href="#更新-etc-hosts文件" class="headerlink" title="更新/etc/hosts文件"></a>更新/etc/hosts文件</h4><p>除了环境变量，Docker 会在目标容器上添加相关主机条目到/etc/hosts中，上例中就是 web 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training/webapp /bin/bash</span><br><span class="line">root@aed84ee21bde:/opt/webapp# cat /etc/hosts</span><br><span class="line">172.17.0.7  aed84ee21bde</span><br><span class="line">. . .</span><br><span class="line">172.17.0.5  db</span><br></pre></td></tr></table></figure><blockquote><p>/etc/host文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。</p></blockquote><h2 id="十、构建私有库"><a href="#十、构建私有库" class="headerlink" title="十、构建私有库"></a>十、构建私有库</h2><p>Docker 官方提供了 docker registry 的构建方法 <a href="https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a></p><h3 id="10-1-快速构建"><a href="#10-1-快速构建" class="headerlink" title="10.1 快速构建"></a>10.1 快速构建</h3><p>快速构建 docker registry 通过以下两步:</p><ul><li>安装 docker</li><li>运行 registry:docker run -p 5000:5000 registry</li></ul><p>这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/" target="_blank" rel="noopener">official image from the Docker hub</a></p><h3 id="10-2-不使用容器构建-registry"><a href="#10-2-不使用容器构建-registry" class="headerlink" title="10.2 不使用容器构建 registry"></a>10.2 不使用容器构建 registry</h3><h4 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev</span><br></pre></td></tr></table></figure><h4 id="配置-docker-registry"><a href="#配置-docker-registry" class="headerlink" title="配置 docker-registry"></a>配置 docker-registry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install docker-registry</span><br></pre></td></tr></table></figure><p>或者 使用 github clone 手动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/dotcloud/docker-registry.git</span><br><span class="line">$ cd docker-registry/</span><br><span class="line">$ cp config/config_sample.yml config/config.yml</span><br><span class="line">$ mkdir /data/registry -p</span><br><span class="line">$ pip install .</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-registry</span><br></pre></td></tr></table></figure><h4 id="高级启动方式-不推荐"><a href="#高级启动方式-不推荐" class="headerlink" title="高级启动方式 [不推荐]"></a>高级启动方式 [不推荐]</h4><p>使用gunicorn控制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者对外监听开放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><h3 id="10-3-提交指定容器到私有库"><a href="#10-3-提交指定容器到私有库" class="headerlink" title="10.3 提交指定容器到私有库"></a>10.3 提交指定容器到私有库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04</span><br><span class="line">$ docker push 私有库IP:5000/ubuntu</span><br></pre></td></tr></table></figure><h2 id="十一、docker-启动redis"><a href="#十一、docker-启动redis" class="headerlink" title="十一、docker 启动redis"></a>十一、docker 启动redis</h2><p><strong>一.docker运行单个redis</strong></p><ol><li>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener">https://hub.docker.com/_/redis/</a></li><li>拉取镜像：docker pull redis</li><li>执行指令启动Redis</li></ol><p>docker run –name redis -d -p 6379:6379 redis</p><p><strong>二.docker运行单个redis</strong></p><p>1.拉取镜像: <code>docker pull redis</code></p><p>2.运行容器(本地image是:docker.io/redis latest 8f2e175b3bd1 2 weeks ago 106.6 MB):</p><p><code>docker run -d --name my_redis -p 6379:6379 -v /data/redis/data/:/data redis redis-server</code></p><ul><li>-d是后台运行;</li><li>–name是设置别名</li><li>-v /data/redis/data/:/data是将 /data/redis/data/挂载到容器的/data(数据默认存储在VOLUME /data目录下,可以使用$PWD/data代替/data/redis/data/)</li></ul><p>3.运行客户端:</p><p><code>docker run -it --link my_redis --rm docker.io/redis redis-cli -h my_redis -p 6379</code></p><ul><li>-it是交互模式(-i: 以交互模式运行容器,-t: 为容器重新分配一个伪输入终端)</li><li>–link 连接另一个容器,这样就可以使用容器名作为host了</li><li>–rm 自动清理容器,因为这里是测试,属于前台程序</li></ul><p><strong>二.docker运行redis主从复制模式（以两个数据库为例）</strong><br><em>主从复制模式:主数据库(master)可以读写,从数据库(slave)只能读;主数据库的写会同步到从数据库,从数据库主要负责读操作。一个主数据库可以拥有多个从数据库，一个从数据库只能拥有一个主数据库。</em></p><p>1.启动两个服务端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-master -v /data/redis/data/:/data  redis redis-server</span><br><span class="line">docker run  -d --name redis-slave --link redis-master redis redis-server --port 6380 --slaveof redis-master 637912</span><br></pre></td></tr></table></figure><p>2.启动对应的客户端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --link redis-master --rm redis redis-cli -h redis-master -p 6379</span><br><span class="line">docker run -it --link redis-slave --rm redis redis-cli -h redis-slave -p 638012</span><br></pre></td></tr></table></figure><p>使用：<code>slaveof no one</code>退出主从关系</p><h2 id="十二、docker-部署zookeeper"><a href="#十二、docker-部署zookeeper" class="headerlink" title="十二、docker 部署zookeeper"></a>十二、docker 部署zookeeper</h2><ol><li>镜像下载</li></ol><p>hub.docker.com 上有不少 ZK 镜像, 不过为了稳定起见, 我们就使用官方的 ZK 镜像吧.<br>首先执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure><p>当出现如下结果时, 表示镜像已经下载完成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; docker pull zookeeper</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/zookeeper</span><br><span class="line"></span><br><span class="line">e110a4a17941: Pull complete</span><br><span class="line">a696cba1f6e8: Pull complete</span><br><span class="line">bc427bd93e95: Pull complete</span><br><span class="line">c72391ae24f6: Pull complete</span><br><span class="line">40ab409b6b34: Pull complete</span><br><span class="line">d4bb8183b85d: Pull complete</span><br><span class="line">0600755f1470: Pull complete</span><br><span class="line">Digest: sha256:12458234bb9f01336df718b7470cabaf5c357052cbcb91f8e80be07635994464</span><br><span class="line">Status: Downloaded newer image for zookeeper:latest</span><br></pre></td></tr></table></figure><p>2.启动 ZK 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; docker run --name my_zookeeper -d zookeeper:latest</span><br></pre></td></tr></table></figure><p>这个命令会在后台运行一个 zookeeper 容器, 名字是 <strong>my_zookeeper</strong>, 并且它默认会导出 2181 端口.<br>接着我们使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f my_zookeeper</span><br></pre></td></tr></table></figure><p>这个命令查看 ZK 的运行情况, 输出类似如下内容时, 表示 ZK 已经成功启动了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; docker logs -f my_zookeeper</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">...</span><br><span class="line">2016-09-14 06:40:03,445 [myid:] - INFO  [main:NIOServerCnxnFactory@89] - binding to port 0.0.0.0/0.0.0.0:2181</span><br></pre></td></tr></table></figure><p>3.使用 ZK 命令行客户端连接 ZK</p><p>因为刚才我们启动的那个 ZK 容器并没有绑定宿主机的端口, 因此我们不能直接访问它. 但是我们可以通过 Docker 的 link 机制来对这个 ZK 容器进行访问. 执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --link my_zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br></pre></td></tr></table></figure><p>如果对 Docker 有过了解的话, 那么对上面的命令一定不会陌生了.<br>这个命令的含义是:</p><ol><li><p>启动一个 zookeeper 镜像, 并运行这个镜像内的 zkCli.sh 命令, 命令参数是 “-server zookeeper”</p></li><li><p>将我们先前启动的名为 my_zookeeper 的容器连接(link) 到我们新建的这个容器上, 并将其主机名命名为 <strong>zookeeper</strong></p></li></ol><p>当我们执行了这个命令后, 就可以像正常使用 ZK 命令行客户端一样操作 ZK 服务了.</p><h2 id="ZK-集群的搭建"><a href="#ZK-集群的搭建" class="headerlink" title="ZK 集群的搭建"></a>ZK 集群的搭建</h2><p>因为一个一个地启动 ZK 太麻烦了, 所以为了方便起见, 我直接使用 docker-compose 来启动 ZK 集群.<br>首先创建一个名为 <strong>docker-compose.yml</strong> 的文件, 其内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    zoo1:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo1</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2181:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 1</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line"></span><br><span class="line">    zoo2:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo2</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2182:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 2</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line"></span><br><span class="line">    zoo3:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo3</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2183:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 3</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure><p>这个配置文件会告诉 Docker 分别运行三个 zookeeper 镜像, 并分别将本地的 2181, 2182, 2183 端口绑定到对应的容器的2181端口上.<br><strong>ZOO_MY_ID</strong> 和 <strong>ZOO_SERVERS</strong> 是搭建 ZK 集群需要设置的两个环境变量, 其中 <strong>ZOO_MY_ID</strong> 表示 ZK 服务的 id, 它是1-255 之间的整数, 必须在集群中唯一. <strong>ZOO_SERVERS</strong> 是ZK 集群的主机列表.</p><p>接着我们在 docker-compose.yml 当前目录下运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPOSE_PROJECT_NAME=zk_test docker-compose up</span><br></pre></td></tr></table></figure><p>即可启动 ZK 集群了.<br>执行上述命令成功后, 接着在另一个终端中运行 <strong>docker-compose ps</strong> 命令可以查看启动的 ZK 容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; COMPOSE_PROJECT_NAME=zk_test docker-compose ps</span><br><span class="line">Name              Command               State           Ports</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">zoo1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2181-&gt;2181/tcp</span><br><span class="line">zoo2   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2182-&gt;2181/tcp</span><br><span class="line">zoo3   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2183-&gt;2181/tcp</span><br></pre></td></tr></table></figure><blockquote><p>注意, 我们在 “docker-compose up” 和 “docker-compose ps” 前都添加了 <strong>COMPOSE_PROJECT_NAME=zk_test</strong> 这个环境变量, 这是为我们的 compose 工程起一个名字, 以免与其他的 compose 混淆.</p></blockquote><h3 id="使用-Docker-命令行客户端连接-ZK-集群"><a href="#使用-Docker-命令行客户端连接-ZK-集群" class="headerlink" title="使用 Docker 命令行客户端连接 ZK 集群"></a>使用 Docker 命令行客户端连接 ZK 集群</h3><p>通过 <strong>docker-compose ps</strong> 命令, 我们知道启动的 ZK 集群的三个主机名分别是 zoo1, zoo2, zoo3, 因此我们分别 link 它们即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">        --link zoo1:zk1 \</span><br><span class="line">        --link zoo2:zk2 \</span><br><span class="line">        --link zoo3:zk3 \</span><br><span class="line">        --net zktest_default \</span><br><span class="line">        zookeeper zkCli.sh -server zk1:2181,zk2:2181,zk3:2181</span><br></pre></td></tr></table></figure><h3 id="通过本地主机连接-ZK-集群"><a href="#通过本地主机连接-ZK-集群" class="headerlink" title="通过本地主机连接 ZK 集群"></a>通过本地主机连接 ZK 集群</h3><p>因为我们分别将 zoo1, zoo2, zoo3 的 2181 端口映射到了 本地主机的2181, 2182, 2183 端口上, 因此我们使用如下命令即可连接 ZK 集群了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh -server localhost:2181,localhost:2182,localhost:2183</span><br></pre></td></tr></table></figure><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><p>我们可以通过 nc 命令连接到指定的 ZK 服务器, 然后发送 stat 可以查看 ZK 服务的状态, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; echo stat | nc 127.0.0.1 2181</span><br><span class="line">Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.18.0.1:49810[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 5/39/74</span><br><span class="line">Received: 4</span><br><span class="line">Sent: 3</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x200000002</span><br><span class="line">Mode: follower</span><br><span class="line">Node count: 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; echo stat | nc 127.0.0.1 2182</span><br><span class="line">Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.18.0.1:50870[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 2</span><br><span class="line">Sent: 1</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x200000002</span><br><span class="line">Mode: follower</span><br><span class="line">Node count: 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; echo stat | nc 127.0.0.1 2183</span><br><span class="line">Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.18.0.1:51820[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 2</span><br><span class="line">Sent: 1</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x200000002</span><br><span class="line">Mode: leader</span><br><span class="line">Node count: 4</span><br></pre></td></tr></table></figure><h2 id="十三、docker-部署-rabbitmq"><a href="#十三、docker-部署-rabbitmq" class="headerlink" title="十三、docker 部署 rabbitmq"></a>十三、docker 部署 rabbitmq</h2><ol><li><p>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/_/rabbitmq/" target="_blank" rel="noopener">https://hub.docker.com/_/rabbitmq/</a></p></li><li><p>拉取镜像：docker pull rabbitmq，如需要管理界面：docker pull rabbitmq:management</p></li><li><p>执行指令启动RabbitMQ</p><p>无管理界面：</p></li></ol><p>docker run –localhost rabbit-host –name my_rabbit -d -p 5672:5672 rabbitmq</p><p>有管理界面：</p><p>docker run –localhost rabbit-host –name my_rabbit -d -p 5672:5672 -p 15672:15672 rabbitmq:management</p><pre><code>账号：guest 密码：guest
</code></pre><h2 id="十四-、启动Eureka"><a href="#十四-、启动Eureka" class="headerlink" title="十四 、启动Eureka"></a>十四 、启动Eureka</h2><ol><li><p>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/r/springcloud/eureka/" target="_blank" rel="noopener">https://hub.docker.com/r/springcloud/eureka/</a></p></li><li><p>拉取镜像：docker pull springcloud/eureka</p></li><li><p>执行指令启动Eureka</p><p>docker run –name my_eureka -d -p 8761:8761 springcloud/eureka</p></li></ol><h2 id="十五-、启动Config-Server"><a href="#十五-、启动Config-Server" class="headerlink" title="十五 、启动Config Server"></a>十五 、启动Config Server</h2><ol><li><p>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/r/hyness/spring-cloud-config-server/" target="_blank" rel="noopener">https://hub.docker.com/r/hyness/spring-cloud-config-server/</a></p></li><li><p>拉取镜像：docker pull hyness/spring-cloud-config-server</p></li><li><p>在GitHub上准备配置文件：<a href="https://github.com/ErikXu/.NetCore-Spring-Clould/tree/master/Configs" target="_blank" rel="noopener">https://github.com/ErikXu/.NetCore-Spring-Clould/tree/master/Configs</a></p></li><li><p>准备启动资源文件application.yml:</p><p><code>info:</code></p><p><code>`</code>component: config service`</p></li></ol><p><code>server:</code></p><p><code>`</code>port: 8888`</p><p><code>spring:</code></p><p><code>`</code>application:`</p><p><code>`</code>name: git-config`</p><p><code>`</code>profiles:`</p><p><code>`</code>active: dev`</p><p><code>`</code>cloud:`</p><p><code>`</code>config:`</p><p><code>`</code>server:`</p><p><code>`</code>git:`</p><p><code>`</code>uri: https:<code>//github</code>.com<code>/ErikXu/</code>.NetCore-Spring-Clould`</p><p><code>`</code>searchPaths: Configs`</p><p></p><ol start="5"><li>执行指令启动Config Server，注：该指令前无空格</li></ol><p>docker run –name my_config-server -it -d -p 8888:8888 \<br>-v /home/erikxu/config/application.yml:/config/application.yml \<br>hyness/spring-cloud-config-server</p><h2 id="十六-、启动-mysql"><a href="#十六-、启动-mysql" class="headerlink" title="十六 、启动 mysql"></a>十六 、启动 mysql</h2><ol><li>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">https://hub.docker.com/_/mysql/</a></li><li>拉取镜像：docker pull mysql</li><li>准备Mysql数据存放目录，我这里是：/data/mysql</li><li>执行指令启动Mysql</li></ol><p>docker run –name my_mysql -v /data/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:latest</p><h2 id="十七、启动nginx"><a href="#十七、启动nginx" class="headerlink" title="十七、启动nginx"></a>十七、启动nginx</h2><ol><li>拉取官方镜像，镜像地址：<a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">https://hub.docker.com/_/nginx/</a></li><li>拉取镜像：docker pull nginx</li><li>准备配置文件</li></ol><p></p><p>4、执行指令启动Nginx</p><p>docker run –name my_nginx -p 80:80 -v /data/etc/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx</p><p></p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://www.liuyong520.cn/2018/02/12/docker/" title="Docker 容器技术" target="_blank" rel="external">http://www.liuyong520.cn/2018/02/12/docker/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/liuyong520" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/liuyong520" target="_blank"><span class="text-dark">跛足的登山者</span><small class="ml-1x">非著名java程序员</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80Mzk0NC8yMDQ4MA=="><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2018/03/02/distributed/" title="6张图读懂大型网站架构"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2017/08/29/hexo-promise/" title="hexo博客主题优化"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div><aside class="sidebar sidebar-toc" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Docker-简介"><span class="toc-number">1.</span> <span class="toc-text">一、Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-组件与元素"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 组件与元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Docker-守护进程"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 Docker 守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Docker-客户端"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 Docker 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Docker-内部"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 Docker 内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-镜像"><span class="toc-number">1.4.1.</span> <span class="toc-text">Docker 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-仓库"><span class="toc-number">1.4.2.</span> <span class="toc-text">Docker 仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-容器"><span class="toc-number">1.4.3.</span> <span class="toc-text">Docker 容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Docker-安装"><span class="toc-number">2.</span> <span class="toc-text">二、Docker 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Docker-基础用法"><span class="toc-number">3.</span> <span class="toc-text">三、Docker 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Search-images"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Search images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Pull-images"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Pull images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Running-an-interactive-shell"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Running an interactive shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Docker-命令帮助"><span class="toc-number">4.</span> <span class="toc-text">四、Docker 命令帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-docker-help"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 docker help</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-command"><span class="toc-number">4.1.1.</span> <span class="toc-text">docker command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-option"><span class="toc-number">4.1.2.</span> <span class="toc-text">docker option</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-docker-search"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 docker search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-docker-info"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 docker info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-docker-pull-amp-amp-docker-push"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 docker pull &amp;&amp; docker push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-docker-images"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 docker images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-docker-rmi"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 docker rmi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-docker-run"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 docker run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-docker-start-stop-kill…-…"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 docker start|stop|kill… …</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Docker-端口映射"><span class="toc-number">5.</span> <span class="toc-text">五、Docker 端口映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-自动映射端口"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 自动映射端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-绑定端口到指定接口"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 绑定端口到指定接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-TCP-端口"><span class="toc-number">5.2.1.</span> <span class="toc-text">绑定 TCP 端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-UDP-端口"><span class="toc-number">5.2.2.</span> <span class="toc-text">绑定 UDP 端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Docker-网络配置"><span class="toc-number">6.</span> <span class="toc-text">六、Docker 网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Docker-四种网络模式"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Docker 四种网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#host-模式"><span class="toc-number">6.1.1.</span> <span class="toc-text">host 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#container-模式"><span class="toc-number">6.1.2.</span> <span class="toc-text">container 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#none模式"><span class="toc-number">6.1.3.</span> <span class="toc-text">none模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bridge模式"><span class="toc-number">6.1.4.</span> <span class="toc-text">bridge模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-列出当前主机网桥"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 列出当前主机网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-查看当前-docker0-ip"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 查看当前 docker0 ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-运行一个容器"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 运行一个容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用特定范围的-IP"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用特定范围的 IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-不同主机间容器通信"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 不同主机间容器通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装相应依赖软件"><span class="toc-number">6.5.1.</span> <span class="toc-text">安装相应依赖软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桥接网络"><span class="toc-number">6.5.2.</span> <span class="toc-text">桥接网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipework"><span class="toc-number">6.5.3.</span> <span class="toc-text">pipework</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Dockerfile"><span class="toc-number">7.</span> <span class="toc-text">七、Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-FROM"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-MAINTAINER"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 MAINTAINER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-CMD"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-EXPOSE"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-ENV"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-ADD"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-COPY"><span class="toc-number">7.7.</span> <span class="toc-text">7.7 COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-ENTRYPOINT"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exec-form-ENTRYPOINT-例子"><span class="toc-number">7.8.1.</span> <span class="toc-text">Exec form ENTRYPOINT 例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell-form-ENTRYPOINT-例子"><span class="toc-number">7.8.2.</span> <span class="toc-text">Shell form ENTRYPOINT 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-VOLUME"><span class="toc-number">7.9.</span> <span class="toc-text">7.9 VOLUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-USER"><span class="toc-number">7.10.</span> <span class="toc-text">7.10 USER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-WORKDIR"><span class="toc-number">7.11.</span> <span class="toc-text">7.11 WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-ONBUILD"><span class="toc-number">7.12.</span> <span class="toc-text">7.12 ONBUILD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-Dockerfile-Examples"><span class="toc-number">7.13.</span> <span class="toc-text">7.13 Dockerfile Examples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-14-docker-build"><span class="toc-number">7.14.</span> <span class="toc-text">7.14 docker build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15-dockerfile-最佳实践"><span class="toc-number">7.15.</span> <span class="toc-text">7.15 dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-指令"><span class="toc-number">7.15.1.</span> <span class="toc-text">Dockerfile 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、容器数据管理"><span class="toc-number">8.</span> <span class="toc-text">八、容器数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-数据卷"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加一个数据卷"><span class="toc-number">8.1.1.</span> <span class="toc-text">添加一个数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂载宿主机目录为一个数据卷"><span class="toc-number">8.1.2.</span> <span class="toc-text">挂载宿主机目录为一个数据卷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-创建和挂载一个数据卷容器"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 创建和挂载一个数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-备份、恢复或迁移数据卷"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 备份、恢复或迁移数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备份"><span class="toc-number">8.3.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复"><span class="toc-number">8.3.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-删除-Volumes"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 删除 Volumes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、链接容器"><span class="toc-number">9.</span> <span class="toc-text">九、链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-容器命名"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 容器命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-链接容器"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量"><span class="toc-number">9.2.1.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新-etc-hosts文件"><span class="toc-number">9.2.2.</span> <span class="toc-text">更新/etc/hosts文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、构建私有库"><span class="toc-number">10.</span> <span class="toc-text">十、构建私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-快速构建"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 快速构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-不使用容器构建-registry"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 不使用容器构建 registry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装必要的软件"><span class="toc-number">10.2.1.</span> <span class="toc-text">安装必要的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-docker-registry"><span class="toc-number">10.2.2.</span> <span class="toc-text">配置 docker-registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行"><span class="toc-number">10.2.3.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级启动方式-不推荐"><span class="toc-number">10.2.4.</span> <span class="toc-text">高级启动方式 [不推荐]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-提交指定容器到私有库"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 提交指定容器到私有库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、docker-启动redis"><span class="toc-number">11.</span> <span class="toc-text">十一、docker 启动redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、docker-部署zookeeper"><span class="toc-number">12.</span> <span class="toc-text">十二、docker 部署zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZK-集群的搭建"><span class="toc-number">13.</span> <span class="toc-text">ZK 集群的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Docker-命令行客户端连接-ZK-集群"><span class="toc-number">13.1.</span> <span class="toc-text">使用 Docker 命令行客户端连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过本地主机连接-ZK-集群"><span class="toc-number">13.2.</span> <span class="toc-text">通过本地主机连接 ZK 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看集群"><span class="toc-number">13.3.</span> <span class="toc-text">查看集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、docker-部署-rabbitmq"><span class="toc-number">14.</span> <span class="toc-text">十三、docker 部署 rabbitmq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-、启动Eureka"><span class="toc-number">15.</span> <span class="toc-text">十四 、启动Eureka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五-、启动Config-Server"><span class="toc-number">16.</span> <span class="toc-text">十五 、启动Config Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六-、启动-mysql"><span class="toc-number">17.</span> <span class="toc-text">十六 、启动 mysql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七、启动nginx"><span class="toc-number">18.</span> <span class="toc-text">十七、启动nginx</span></a></li></ol></nav></div></aside></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/liuyong520" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/1886570943" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script defer src="https://cdn1.lncld.net/static/js/av-min-1.2.1.js"></script><script defer>function showTime(e){var t=new AV.Query(e),r=$(".leancloud_visitors");t.greaterThanOrEqualTo("time",0),t.find({success:function(e){if(0!=e.length){var t=e;r.each(function(){for(var e=$(this).attr("id").trim(),r=0;r<t.length;r++){var n=t[r],o=n.get("time"),i=n.get("url");e==i&&$(this).text(o)}})}},error:function(e,t){console.log("Error: "+t.code+" "+t.message)}})}function addCount(e){var e=AV.Object.extend("Counter");url=$(".leancloud_visitors").attr("id").trim(),title=$(".leancloud_visitors").attr("data-flag-title").trim();var t=new AV.Query(e);t.equalTo("url",url),t.find({success:function(t){if(t.length>0){var r=t[0];r.fetchWhenSave(!0),r.increment("time"),r.save(null,{success:function(e){var t=e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new e;n.set("title",title),n.set("url",url),n.set("time",1),n.save(null,{success:function(e){console.log("newcounter.get('time')="+e.get("time"));var t=e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}AV.init({appId:"amHYyRIzXluicvuizbeX6JEP-gzGzoHsz",appKey:"d2dvceLKG7rxyvY6BSB2j4Q9"}),$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):showTime(e)})</script><script defer type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?f7bfa65466f219f000d619be05ecf22f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by neat -->