---
title: 分布式系统之分布式事务处理
tags:
  - 分布式系统
categories:
  - 分布式系统
toc: true
comment: true
translate_title: distributed-transaction-processing-for-systems
date: 2018-04-05 17:23:25
---

为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。另外一个例子，当访问单一服务器管理的数据的进程数不断增加时，系统就需要对服务器的数量进行扩充，此时，对服务器进行复制，随后让它们分担工作负荷，就可以提高性能。但同时，如何保障多个数据节点之间数据的一致以及如何处理分布式事务，将成为为一个复杂的话题。本文将介绍常用的事务处理机制。

举个例子：

用户下了一个订单，需要修改余额表，订单表，流水表，于是会有类似的伪代码：
```sql
start transaction;
 CURD table t_account;  any Exception rollback;
 CURD table t_order;    any Exception rollback;
 CURD table t_flow;     any Exception rollback;
commit;
```

- 如果对余额表，订单表，流水表的SQL操作全部成功，则全部提交
- 如果任何一个出现问题，则全部回滚
事务，以保证数据的完整性以及一致性。

# 事务的方案会有什么潜在问题？
答：互联网的业务特点是海量数据，大并发的数据访问量，所以经常使用拆库的方式提升系统的性能。如果进行了拆库，余额、订单、流水可能分布在不同的数据库上，甚至不同的数据库实例上，此时就不能用数据库原生事务来保证数据的一致性了，就需要用到分布式事务才能解决这类问题了。

# 那么常见的分布式事务解决方案有哪些呢？
 
 - 补偿事务
 - 后置提交优化
 - 两阶段提交（2pc）
 - 三阶段提交
 - TCC事务解决方案
 - 可靠消息一致性解决方案

# 什么是补偿事务？

补偿事务，是一种在业务端实施业务逆向操作事务。

举个栗子：
修改余额，事务为：
```java
int Do_AccountT(uid, money){
    start transaction;
         //余额改变money这么多
         CURD table t_account with money for uid;
         anyException rollback return NO;
    commit;
    return YES;
}
```
 
那么，修改余额，补偿事务可以是：

```java
int Compensate_AccountT(uid, money){
         //做一个money的反向操作
         return Do_AccountT(uid, -1*money){
}
``` 

同理，订单操作，事务是：Do_OrderT，新增一个订单；
订单操作，补偿事务是：Compensate_OrderT，删除一个订单。
 
要保证余额与订单的一致性，伪代码：

```java
// 执行第一个事务
int flag = Do_AccountT();
if(flag=YES){
    //第一个事务成功，则执行第二个事务
    flag= Do_OrderT();
    if(flag=YES){
        // 第二个事务成功，则成功
        return YES;
    }
    else{
        // 第二个事务失败，执行第一个事务的补偿事务
        Compensate_AccountT();
    }
}
``` 
# 补偿事务有什么缺点？

- 不同的业务要写不同的补偿事务，不具备通用性；
- 没有考虑补偿事务的失败；
- 如果业务流程很复杂，if/else会嵌套非常多层；

**上面的例子还只考虑了余额+订单的一致性，就有2*2=4个分支，如果要考虑余额+订单+流水的一致性，则会有2*2*2=8个if/else分支，复杂性呈指数级增长。**

# 后置提交优化

举个例子：
单库是用这样一个大事务保证一致性：
```java
start transaction;
 CURD table t_account;  any Exception rollback;
 CURD table t_order;      any Exception rollback;
 CURD table t_flow;        any Exception rollback;
commit;
```
拆分成了多个库后，大事务会变成三个小事务：
```java
start transaction1;
         //第一个库事务执行
         CURD table t_account; any Exception rollback;
         …
// 第一个库事务提交
commit1;
```
```java
start transaction2;
         //第二个库事务执行
         CURD table t_order; any Exception rollback;
         …
// 第二个库事务提交
commit2;
```
```java
start transaction3;
         //第三个库事务执行
         CURD table t_flow; any Exception rollback;
         …
// 第三个库事务提交
commit3;
```
**再次提醒**，这三个事务发生在三个库，甚至3个不同实例的数据库上。

一个事务，分成执行与提交两个阶段：
- 执行(CURD)的时间很长
- 提交(commit)的执行很快

于是整个执行过程的时间轴如下：
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559477428143.png)

第一个事务执行200ms，提交1ms；
第二个事务执行200ms，提交1ms；
第三个事务执行250ms，提交1ms；

# 在什么时候，会出现不一致？
第一个事务成功提交之后，最后一个事务成功提交之前，如果出现问题（例如服务器重启，数据库异常等），都可能导致数据不一致。
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559477840556.png)
如上图，最后452ms可能会出现数据不一致的问题

# 何谓后置提交优化？
如果改变事务执行与提交的时序，变成事务先执行，最后一起提交。就变成了下图
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559478439352.png)
第一个事务执行200ms，第二个事务执行200ms，第三个事务执行250ms；
第一个事务提交1ms，第二个事务提交1ms，第三个事务提交1ms；

# 后置提交优化后，在什么时候，会出现不一致？
第一个事务成功提交之后，最后一个事务成功提交之前，如果出现问题（例如服务器重启，数据库异常等），都可能导致数据不一致 
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559479001240.png)
如上图最后2ms可能会出现数据不一致。

# 有什么区别和差异？

- 串行事务方案，总执行时间是653ms，最后452ms内出现异常都可能导致不一致；
- 后置提交优化方案，总执行时间也是653ms，但最后2ms内出现异常才会导致不一致；
虽然没有彻底解决数据的一致性问题，但不一致出现的概率大大降低了。
上面这个例子，概率降低了250倍。

# 后置提交优化，有什么不足？
对事务吞吐量会有影响：
- 串行事务方案，第一个库事务提交，数据库连接就释放了；
- 后置提交优化方案，所有库的连接，要等到所有事务执行完才释放；
这就意味着，数据库连接占用的时间增长了，系统整体的吞吐量降低了。

# 两阶段提交（2PC）

两阶段提交协议 （Two-phase commit protocol，2PC）的过程涉及到协调者和参与者。协调者可以看做成事务的发起者，同时也是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及到多个参与者的。具体的两阶段提交的过程如下：
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559524279889.png)

## 第一阶段（准备阶段）
协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。

## 第二阶段（提交阶段）
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

当协调者节点从所有参与者节点获得的相应消息都为“同意”时:
- 协调者节点向所有参与者节点发出“正式提交(commit)”的请求。
- 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
- 参与者节点向协调者节点发送“完成”消息。
如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
- 协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
- 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
- 参与者节点向协调者节点发送”回滚完成”消息。
- 协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。
- 协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务
不管最后结果如何，第二阶段都会结束当前事务。

## 二段式提交协议的优缺点：

优点：原理简单，实现方便；

缺点：

- 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。
- 单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。
- 数据不一致。在阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
- 二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
为了解决两阶段提交协议的种种问题，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。

# 三阶段提交（3PC）

三阶段提交协议（Three-phase commit protocol，3PC），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：

- 引入超时机制。同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
即 3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。

## CanCommit 阶段
CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。

- 事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
- 响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No

## PreCommit 阶段
协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。

- 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。
发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入Prepared 阶段。
- 事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将undo 和 redo 信息记录到事务日志中。
- 响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
- 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
- 发送中断请求：协调者向所有参与者发送 abort 请求。
- 中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

## doCommit 阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。

- 执行提交
- 发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。
- 事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
- 响应反馈：事务提交完之后，向协调者发送 ACK 响应。
- 完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。
- 中断事务：协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。
- 发送中断请求：协调者向所有参与者发送 abort 请求
- 事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
- 反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息
- 中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。
在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。即当进入第三阶段时，由于网络超时等原因，虽然参与者没有收 到 commit 或者 abort 响应，事务仍然会提交。

三阶段提交不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。

# TCC事务解决方案
在08年的软件开发2.0技术大会上，支付宝程立在PPT大规模SOA系统中的分布事务处理，提出TCC概念。在网络上搜索分布式事务相关的博客，基本都会提及这个PPT，目前很多分布式事务开源项目也都是基于TCC的思想实现。

TCC 将事务提交分为 Try - Confirm - Cancel 3个操作。

Try：预留业务资源/数据效验
Confirm：确认执行业务操作
Cancel：取消执行业务操作
TCC事务处理流程和 2PC 二阶段提交类似，不过 2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。
![此图摘自网络](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559525194271.png)

事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成一阶段准备。之后事务协调器会根据try接口返回情况，决定调用confirm接口或者cancel接口。如果接口调用失败，会进行重试。
# TCC事务的优缺点
优点：
- 让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。
缺点：
- 对应用的侵入性强。业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，应用侵入性较强，改造成本高。
- 实现难度较大。需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口必须实现幂等。

举个例子：
支付宝红包+余额支付的例子：用户下一个订单等待支付，会修改余额账户和红包账户系统的钱。
假设用户下单操作来自3个系统下单系统、资金账户系统、红包账户系统，下单成功需要同时调用资金账户服务和红包服务完成支付

假设购买商品1000元，使用账户红包200元，余额800元，确认支付。
伪代码：
```
Try操作
tryX create tb_order   //下单系统创建待支付订单
tryY freeze tb_balance //update tb_balance set freezebanlance=freezebalance+200 冻结账户红包200元
tryZ freeze tb_account //update tb_balance set freezeaccount=freezeaccount+800 冻结资金账户800元

Confirm操作
confirmX update tb_order set state="success" // 订单更新为支付成功
confirmY update tb_balance set balance= balance-200//扣减账户红包200元
confirmZ update tb_account set account= account-800 //扣减资金账户800元

Cancel操作
cancelX 订单处理异常，资金红包退回，订单支付失败
cancelY 冻结红包失败，账户余额退回，订单支付失败
cancelZ 冻结余额失败，账户红包退回，订单支付失败
```
# 可靠消息一致性解决方案
消息一致性方案是通过消息中间件保证上、下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。
![enter description here](https://www.github.com/liuyong520/pic/raw/master/小书匠/1559527994255.png)
消息方案从本质上讲是将分布式事务转换为两个本地事务，然后依靠下游业务的重试机制达到最终一致性。基于消息的最终一致性方案对应用侵入性也很高，应用需要进行大量业务改造，成本较高。